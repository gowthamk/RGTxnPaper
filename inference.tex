\section{Inference}
\label{sec:inference}

The rely-guarantee framework presented in the previous section
facilitates modular proofs for weakly-isolated transactions, but
imposes a non-trivial annotation burden.  In particular, it requires
each statement ($c$) of the transaction to be annotated with a stable
pre- ($P$) and post-condition ($Q$), and loops to be annotated with
stable inductive invariants ($\psi$). While weakest pre-condition
style predicate transformers can help in inferring intermediate
assertions for regular statements, loop invariant inference remains
challenging, even for the simple form of loops considered here.  As an
alternative, we present an inference algorithm based on state
transformers that alleviates this burden.  The idea is to infer the
logical effect that each statement has on the transaction-local
database state $\stl$ (i.e., how it transforms $\stl$), and compose
multiple such effects together to describe the effect of the
transaction as a whole.  Importantly, this approach generalizes to
loops, where the effect of a loop can be inferred as a well-defined
function of the effect of its body, thanks to certain pleasant
properties enjoyed by the database programs modeled by our core
language.  Interpreting database semantics as functional
transformations on sets (described in terms of their logical effects)
enables an inference mechanism that can leverage off-the-shelf SMT
solvers for automated verification.

\input{logic-syntax}

At the core of our approach is a simple language ($\SL$) to express
set transformations (see Fig.~\ref{fig:logic-syntax}). The language
admits set expressions that include variables ($x$), literals of the
form $\{x \,|\, \varphi\}$ where $\varphi$ is a propositional
(quantifier-free) formula on $x$, a restricted form of existential
quantification that binds a set $\stg$ satisfying proposition $\phi$
in a set expression $s$, a monadic composition of two set expressions
($s_1$ and $s_2$) composed using a bind ($\bind$) operation, a
conditional set expression where the condition is a propositional
formula, and a union of two set expressions. Symbols $\stl$ and $\stg$
are also variables in $\SL$, but are used to denote local and database
states (also represented as sets), respectively. Constant sets can be
written using set literal expressions. For example, the set $\{1,2\}$
can be written as $\{x \,|\, x=1 \vee x=2\}$. The language is
carefully chosen to be expressive enough to capture the semantics of
$\txnimp$ statements (as well as SQL operations more generally), yet
simple enough to have a semantics-preserving translation amenable for
automated verification.

\input{inference-rules}

Fig.~\ref{fig:inference-rules} shows the syntax-directed state
transformer inference rules for $\txnimp$ commands inside a
transaction $\C{TXN}_i$. The rules compute, for each command $c$, a
(meta) function $\F$ that returns a set of records as an expression in
$\SL$, given a global database $\stg$. Intuitively, $\F(\stg)$
abstracts the set of records added to the local database $\stl$ as a
result of executing $c$ under $\stg$ (i.e., $\stg \vdash
(\tbox{c}_i,\stl) \stepsto^{*}_{R} (\tbox{\cskip}_i, \stl \cup
\F(\stg))$)\footnote{Recall that the operational semantics treats 
  deletion of records as the addition of the deleted record with its
  \C{del} field set to true in the local store.}. Note that the
function $\F$ we call state transformer here is actually the
\emph{effect} part of the state transformer introduced in
Sec.~\ref{sec:motivation}, which is a function $\T$ of the form
$\lambda(\stl,\stg).~\stl \cup \F(\stg)$. Nonetheless, for simplicity,
we will continue to refer to $\F$ as state transformer. Since the execution is subject
to isolation-constrained interference, the inference judgment depends
on the isolation-constrained rely relation $\R$, which is used to
enforce the stability of the state transformer $\F$.  Recall that $\R$
is a tri-state rely relation over $\stl$, $\stg$ and $\stg'$, that
admits an interference from $\stg$ and $\stg'$ depending on the local
database state $\stl$. Thus, the stability of the state transformer
$\F$ of $c$ with respect to $\R$ needs to take into account the
(possible) prior state of the local database $\stl$, which depends on
the context (sequence of previous commands) of $c$, and computed by
the corresponding state transformer $\Fx$. Thus, the semantics of the
state transformer can be understood in terms of the RG judgment as
following (formalized as Theorem~\ref{thm:inference-sound} in
Sec.~\ref{sec:inference-sound}):
\begin{smathpar}
  \begin{array}{c}
    \R \vdash \hoare{\lambda(\stl,\stg).~ \stl = \Fx(\stg)}{c}
    {\lambda(\stl,\stg).~ \stl = \Fx(\stg) \cup \F(\stg)}
  \end{array}
\end{smathpar}
In the above RG judgment, let $P$ denote the pre-condition
$\lambda(\stl,\stg).~ \stl = \Fx(\stg)$, and let $Q$ denote the
post-condition $\lambda(\stl,\stg).~ \stl = \Fx(\stg) \cup \F(\stg)$.
The stability condition on the state transformer $\F$ can be derived
from the stability condition on $Q$. Observe that for $Q$ to be
stable, $\Fx(\stg') \cup \F(\stg')$ must be equal to $\Fx(\stg) \cup
\F(\stg)$, where $\stg$ and $\stg'$ are related by $R$ (ignore $\I$
for the moment). Assuming that $P$ is stable, $\Fx(\stg')=\Fx(\stg)$
is already given, leaving $\F(\stg')=\F(\stg)$ to be enforced. Thus,
the stability of $\F$ in in the context of $\Fx$ (written
$\inctxt{\Fx}{\F}$) is defined as following:
\begin{smathpar}
\begin{array}{lcl}
  \stable(\R,\inctxt{\Fx}{\F}) & \Leftrightarrow & \forall \stg,\stg',\nubar.~
  \R(\Fx(\stg) \cup \F(\stg),\stg,\stg') \Rightarrow \F(\stg) = \F(\stg')
\end{array}
\end{smathpar}
where $\nubar$ are the variables that occur free in $\F$; this is
possible because of how the inference rules are structured. The
equality in $\SL$ translates to equivalence in first-order logic, as
we describe later. In the inference rules, stability is enforced
constructively by a meta-function $\stabilize{\cdot}$, which accepts
a transformer $\F$ (in its context $\Fx$) and returns a new
transformer that is guaranteed to be stable under $\R$.
$\stabilize{\cdot}$ achieves the stability guarantee by abstracting
away the bound global state ($\stg$) in an unstable $\F$ to an
existentially bound $\stg'$ as described below:
\begin{smathpar}
\begin{array}{lcll}
  \stabilize{\inctxt{\Fx}{\F}} & = & \F & \texttt{if }
  \stable(\R,\inctxt{\Fx}{\F}).\\
  & = & \lambda (\stg).~\existsl(\stg',I(\stg'),\F(\stg')) 
      & \texttt{otherwise. }\stg'\texttt{ is a fresh name.}\\
\end{array}
\end{smathpar}
Observe that when $\F$ is not stable, $\stabilize{\F}$ returns a
transformer $\F'$ that simply ignores its $\stg$ argument in favor of
a generic $\stg'$, making $\F'$ trivially stable. It is safe to assume
$I(\stg')$ because all verified transactions must preserve the
invariant, and hence only valid database states will ever be
witnessed. From the perspective of RG reasoning, $\stabilize{\cdot}$
effectively weakens the post-condition of a statement, as done by the
\rulelabel{RG-Conseq} rule for transaction-bound commands.  The
weakening semantics chosen by $\stabilize{\cdot}$, while being simple,
is nonetheless useful because of the $I(\stg')$ assumption imposed on
an existentially bound $\stg'$. The example in
Fig.~\ref{fig:weakening-example} demonstrates.
\begin{figure}[h]
\begin{center}
\begin{ocaml}
let add_interest acc_id pc = atomically_do @@ fun () ->
  let a = SQL.select1 BankAccount (fun acc -> acc.id = acc_id) in
  let y = a.bal + pc*a.bal in
  SQL.update BankAccount (fun acc -> {acc with bal = acc.bal + y})
                         (fun acc -> acc.id = acc_id)
\end{ocaml}
\end{center}
\caption{A transaction that deposits an interest to a bank account.}
\label{fig:weakening-example}
\end{figure}
Here, an \C{add\_interest} transaction adds a positive interest
(determined by \C{pc}) to the balance of a bank account, which is
required to be non-negative ($I(\stg) \Leftrightarrow
\forall(r\in\stg).~r.\C{bal}\ge 0$). The transaction starts by issuing
a \C{select1} query, whose transformer $\F$ is essentially a singleton
set containing a record $r$ whose id is \C{acc\_id} (i.e.,
$\F(\stg) = \{r \,|\, r\in\stg \wedge r.\C{id} = \C{acc\_id}\}$).
However, $\F$ is unstable because $\F(\stg')$ may not be
the same set as $\F(\stg)$ when $\stg'\neq\stg$. A record
$r\in\stg$ whose $\C{id}=\C{acc\_id}$ may have its balance updated by
a concurrent \C{withdraw} or \C{deposit} transaction in $\stg'$,
making the record in $\stg'$ different from the record in $\stg$.
Hence the stability check fails.  Fortunately, the weakening operator
($\stabilize{\cdot}$) allows us to weaken the effect to
$\existsl(\stg, I(\stg), \{ r \,|\, r\in\stg \wedge
r.\C{id}=\C{acc\_id}\})$, which effectively asserts that the
\C{select1} query returns a record with $\C{id}=\C{acc\_id}$ from
\emph{some} database state that satisfies the non-negative balance
invariant $I$.  This weakened assertion is nonetheless enough to
deduce that $\C{a.bal}\ge0$, and subsequently prove that $\C{a.bal +
pc*a.bal}\ge 0$, allowing us to verify the \C{add\_interest}
transaction.

The state transformer rules, like the earlier RG rules, closely follow
the corresponding reduction rules in Fig.~\ref{fig:txnimp}, except
that their language of expression is $\SL$. For instance, while the
reduction rule for \C{UPDATE} declaratively specifies the set of
updated records, the state transformer rule uses $\SL$'s bind
operation to \emph{compute} the set. Other SQL rules do likewise. The
rules for \C{LET} binders, conditionals, and sequences compose the
effects inferred for their subcommands. Thus, the effect of a sequence
of commands $c_1;c_2$ is the union of effects $\F_1$ and $\F_2$ of
$c_1$ and $c_2$, respectively, except that $\F_2$ is computed in a
context that includes $\F_1$ (we write $\F_1 \cup \F_2$ as a shorthand
for $\lambda(\stg).~\F_1(\stg) \cup \F_2(\stg)$). The inference rule
for \C{FOREACH} takes advantage of the $\SL$'s bind operator to lift
the effect inferred for the loop body to the level of the loop. Since
records added to $\stl$ in each iteration of \C{FOREACH} are
independent of the previous iteration (recall that we make a local
context independence assumption about database programs; Sec.
~\ref{sec:opsem}), sequential composition of the effects of different
iterations is the same as their parallel composition. Since the loop
body is executed once per each $z\in x$, the effect of the the loop is
a union of effects ($\F$) for all $z\in x$, all applied to the same
state ($\stg$).  That is, $\F_{loop}(\stg) = \bigcup_{z\in
x}\F_{body}(\stg)$. From the definition of the set monad's bind
operator, $\F_{loop}(\stg) = x \bind (\lambda z.~F_{body}(\stg))$,
which mirrors the definition of the rule.
%This development mirrors ideas found in type checkers for certain
%dependent type systems~\cite{KJ14}.


% \begin{figure}[h]
% \begin{smathpar}
% \begin{array}{l}
%   \foreache{xs}{(\lambda y.\lambda x.~ 
%         \updatee{(\lambda z.~ \{\idf=z.\idf;\,\C{name}=z.\C{name};\,
%                                \C{s\_id}=x.\idf\})}
%                 {(\lambda z.~ z.\idf = x.\C{s\_id})};\\
%         \hspace*{1.27in} \inserte{x})}
% \end{array}
% \end{smathpar}
% \caption{A $\txnimp$ program that populates a database
%   of couples.}
% \label{fig:people_code}
% \end{figure}

%% \begin{example}
%% Consider a database of couples that tracks the spouse
%% relationship. Each record has an $\idf$ field, a \C{name} field, and a
%% spouse id (\C{s\_id}) field. A $\txnimp$ transaction bearing id $i$
%% that populates the database with a given set ($xs$) of couples will
%% include the following code snippet:
%% \begin{smathpar}
%% \begin{array}{l}
%%   \foreache{xs}{(\lambda y.\lambda x.~ 
%%         \updatee{(\lambda z.~ \{\idf=z.\idf;\,\C{name}=z.\C{name};\,
%%                                \C{s\_id}=x.\idf\})}
%%                 {(\lambda z.~ z.\idf = x.\C{s\_id})};\\
%%         \hspace*{1.27in} \inserte{x})}
%% \end{array}
%% \end{smathpar}
%% The effect captured by a state transformer inferred for the program, assuming no interference would be:
%% \begin{smathpar}
%% \begin{array}{l}
%%   \lambda(\stl,\stg).~xs \bind 
%%     (\lambda x. \stg \bind 
%%       (\lambda z. \itel{z.\idf = x.\C{s\_id}}
%%                        {\{\{\idf=z.\idf;\,\C{name}=z.\C{name};\,
%%                                \C{s\_id}=x.\idf\}\}}
%%                        {\emptyset}) \\
%%       \hspace*{1cm} ~\cup~ \{y \,|\, y = \{x \with \delf=\mathit{false}; \}\})
%% \end{array}
%% \end{smathpar}
%% Under the possibility of an interference affecting the stability, the
%% following stable effect is inferred ($I$ is the database invariant):
%% \begin{smathpar}
%% \begin{array}{l}
%%   \lambda(\stl,\stg).~xs \bind 
%%     (\lambda x.~\existsl(\stg',I,\stg' \bind 
%%       (\lambda z. \itel{z.\idf = x.\C{s\_id}}
%%                        {\{\{\idf=z.\idf;\,\C{name}=z.\C{name};\,
%%                                \C{s\_id}=x.\idf\}\}}
%%                        {\emptyset})) \\
%%       \hspace*{1cm} ~\cup~ \{y \,|\, y = \{x \with \delf=false; \}\})
%% \end{array}
%% \end{smathpar}
%% \end{example}

\subsection{Soundness of Inference}
\label{sec:inference-sound}

We now formally state the correspondence between the inference rules
given above and the RG judgment of \S\ref{sec:reasoning}:
\begin{theorem}
  \label{thm:inference-sound}
  For all $i$,$R$,$I$,$c$,$\Fx$, $\F$, if $\stable(\R,I)$ and $\Fx
  \vdash c \elabsto \F$, then:\\\vspace*{-0.2cm}
  \begin{smathpar}
  \begin{array}{c}
    \R \vdash \hoare{\lambda(\stl,\stg).~\stl=\Fx(\stg) \conj
    I(\stg)}{c}{\lambda(\stl,\stg).~\stl = \Fx(\stg) \cup \F(\stg)
    \conj I(\stg)}
  \end{array}
  \end{smathpar}
\end{theorem}

\paragraph{{\sc Proof Sketch.}} 
% We prove a slightly stronger statement :
% For all  $i$,$R$,$I$,$c$,$\F$,$s$ if $\stable(\R,I)$ and $c \elabsto \F$, then:
%   \begin{smathpar}
%     \begin{array}{c}
%     \R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
%     I(\stg)}{c}{\lambda(\stl,\stg).\stl = \F(s,\stg)}
%     \end{array}
%   \end{smathpar}
The proof follows by structural induction on $c$. Assume that $P
\Leftrightarrow \lambda(\stl,\stg).~\stl=s \conj I(\stg)$ and $Q
\Leftrightarrow \lambda(\stl,\stg).\stl = \F(s,\stg)$. For each type
of $c$, our strategy is to show the premises of the corresponding
RG-rule. The base cases correspond to \C{INSERT}, \C{UPDATE} and \C{DELETE}
statements. In all these cases, the form of $\F$ directly corresponds
to the condition linking the pre-condition $P$ and post-condition $Q$
in the premises of the RG-rules. If $\stable(\R, \F)$, then
$\stabilize{\F} = \F$ and hence the proof directly follows. Otherwise,
$\stabilize{\F} = \lambda (\stg).\existsl(\stg', I(\stg'),
\F( \stg'))$. Since the pre-condition $P(\stl, \stg)$ asserts
$I(\stg)$, any state which obeys $P$ provides the existential $\stg'$
in the above set expression, and hence $\F$ applied on that state
matches the condition linking $P$ and $Q$. The stability of $P$ with
respect to $\R$ follows directly from the stability of $I$.

The proofs for \C{SELECT}, sequencing, and conditionals use the
inductive hypothesis to infer the RG-judgments present in the
premises of their corresponding RG-rules. The interesting case is the
\C{FOREACH} statement, for which we use the loop invariant
$\psi(\stl, \stg) \Leftrightarrow \stl = s \cup (y \bind (\lambda
z.~\F(s, \stg)))$, (where assuming that $c$ is the body of the loop,
$c \elabsto \F$) to prove all the premises of
\rulelabel{RG-Foreach}. Using the same notation as the rule
$\rulelabel{RG-Foreach}$, $y$ refers to the records already processed
in previous iterations of the loop, while $z$ refers to the record
being processed in the current iteration.  At the beginning of the
loop $[\phi/y]\psi(\stl, \stg)$ just reduces to $\stl = s$ which is
implied by the pre-condition $P$. From the inductive hypothesis, we
can infer that each iteration corresponds to the application of
$\F$. Since all iterations are assumed to be independent of each other,
and $z$ is bound to a record in $x$ for each iteration, we conclude
that at the end of every iteration, the loop invariant $[y \cup
  \{z\}/y]\psi$ will be satisfied.

\subsection{From $\SL$ to the first-order logic}

\input{logic}

Theorem~\ref{thm:inference-sound} lets us replace the local judgment
of the \rulelabel{RG-Txn} rule (Fig.~\ref{fig:rg-rules}) by a state
transformer inference judgment. The soundness of a transaction's
guarantee can now be established w.r.t the effect $\F$ of the body.
The \rulelabel{RG-Txn} rule so updated is shown below ($\Fempty =
\lambda(\stg).~\emptyset$ denotes an empty context):
\begin{smathpar}
\begin{array}{c}
\RULE
{
   \stable(R,\I)\spc
   \stable(R,I)\\
   \R_e = R \backslash \I_e \spc \R_c = R \backslash \I_c \spc
   \Fempty \vdash c \Longrightarrow_{\langle i,\R_e,I \rangle}\F \\
   \stable(\R_c,\inctxt{\Fempty}{\F}) \spc
   \forall \stg.~ G(\stg,\F(\stg)) \spc
   \forall \stg,\stg'.~I(\stg) \wedge G(\stg,\stg') \Rightarrow I(\stg')\\
}
{
  \rg{I,R}{\ctxn{i}{\I}{c}}{G,I}
}
\end{array}
\end{smathpar}
% \begin{smathpar}
% \begin{array}{c}
% \RULE
% {
%   \stable(R,\I)\spc
%   \stable(R,I)\spc
%   P(\stl,\stg) \Leftrightarrow \stl=\emptyset \wedge I(\stg)\\
%   \R_e = R \backslash \I_e \spc \R_c = R \backslash \I_c \spc 
%    \R_e \vdash \rg{P}{c}{Q} \spc \stable(\R_c,Q) \\ 
%   \forall \stl,\stg.~ Q(\stl,\stg) \Rightarrow 
%     G(\stg, \stl \rhd \stg)\spc
%   \forall \stg,\stg'.~I(\stg) \wedge G(\stg,\stg') \Rightarrow I(\stg')\\
% }
% {
%   \rg{I,R}{\ctxn{i}{\I}{c}}{G,I}
% }
% \end{array}
% \end{smathpar}
Automating the application of the \rulelabel{RG-Txn} rule for a
transaction requires automating the multiple implication checks in
the premise. While $R$, $G$, $\I$ and $I$ are formulas in
first-order logic (FOL) with a relatively simple structure, $\F$
is an expression in the set language $\SL$
(Fig.~\ref{fig:logic-syntax}) with a possibly complex structure.
Fortunately, however, there exists a semantics-preserving translation
from $\SL$ to a restricted subset of first-order logic (FOL) that
lends itself to automatic reasoning. 

The algorithm ($\mssemof{\cdot}{\cdot}$) shown in Fig.~\ref{fig:logic}
translates an $\SL$ expression ($s$) to FOL. The translation is based
on encoding a set of element type $T$ as a unary predicate on $T$.
The predicate is represented as a meta function that accepts an $x:T$
and returns a quantifier-free proposition that evaluates to true
($\top$) if and only if $x$ is present in the set. Alternatively,
the translation may also encode the set as a predicate in the logic
itself, in which case a quantified proposition constraining the
predicate is also generated. For instance, consider the set $\{1,2\}$.
The predicate describing the set can be encoded as the function
$\lambda \v. \v=1 \vee \v=2$, with no further constraints, or it can
be encoded as the function $\lambda \v. g(\v)$ with an associated
constraint ($\phi\in\Prop^1$) defining the uninterpreted boolean
function (i.e., uninterpreted predicate) $g$:
\begin{smathpar}
  \begin{array}{lcl}
    \phi & = & \forall \nu.~g(\nu) \Leftrightarrow \nu=1 \vee \nu=2
  \end{array}
\end{smathpar}
The translation adopts one or the other approach, depending on the
need. For uniformity, we consider the encoding of a set as pair
($\phi$,$\G$), where $\G$ is a meta function, and $\phi$ is a FOL
formula constraining any uninterpreted predicates used in $G$.

Due to the presence of bind ($\bind$) in $\SL$, a set expression $s$
may contain free variables introduced by an enclosing binder. For
instance, consider the $\SL$ expression $s_1\bind(\lambda x. \{ y\,|\,
y=x+1\})$, where $s_1$ is an integer set (expression). The
subexpression $\{ y\,|\, y=x+1\}$ (call it $s_2$) contains $x$ as a
free variable. In such cases, the predicate associated with the
subexpression should also be indexed by its free variables so that a
unique set exists for each instantiation of the free variables. Thus,
the predicate ($\G$) associated with the subexpression from the
above example should be $\lambda\v_1.\lambda\v_2.~\v_2 = \v_1 + 1$, so
that the set $\G\; x_1$ is different from the set $\G\; x_2$ for
distinct $x_1,x_2 \in s_1$. Intuitively, the bind expression
$s_1\bind(\lambda x. \{ y\,|\, y=x+1\})$ denotes the set
$\bigcup\limits_{x\in s_1}\G\;x$.

The translation algorithm (Fig.~\ref{fig:logic}) takes free variables
into account. Given a set expression $s\in\SL$, whose (possible) free
variables are $\nubar$ in the order of their introduction (top-most
binder first), $\mssemof{\nubar}{s}$ returns the encoding of $s$ as
$(\phi,\G)$.  The meta-function $\G$ is a predicate indexed by the
(possible) free variables of $s$, and thus its arity is $|\nubar| + 1$.
Note that $\nubar$ is only a sequence of variables introduced by the
enclosing binders of $s$, and not all may actually occur free in $s$.
Nonetheless, its predicate $\G$ is always indexed by $|\nubar|$ free
variables for uniformity. The translation encodes database state as an
uninterpreted sort. Considering that the state is actually a set of
records, we define an uninterpreted relation ``$\in$'' to relate records
and states. Thus, a variable set expression $\stg$ denoting a database
state is encoded as the predicate $\lambda (\vbar,r).~r\in\stg$, where
$|\vbar|=|\nubar|$ (predicates are uncurried for simplicity; $\vbar$
is a comma-separated sequence; $r\not\in\SL$ is a special variable).
The constraints associated with the encoding of a state are trivial
(denoted $\top$). The set literal expression $\{x\,|\, \varphi\}$ is encoded
straightforwardly. The conditional set expression is encoded as an
if-then-else predicate in FOL, where the predicates on true and false
branches are computed from the set subexpressions $s_1$ and $s_2$,
respectively. The conjunction of constraints $\phi_1$ and $\phi_2$,
from $\mssemof{\nubar}{s_1}$ and $\mssemof{\nubar}{s_2}$ (resp.), is
propagated upwards as the constraint of the conditional expression.
A set union expression is encoded similarly.

The first-order encoding of a bind expression describes the semantics
of the set monad's bind operator in FOL. Let $s_1$ be a set, and let
$f$ be a function that maps each variable in $s_1$ to a new set. Then,
$s_2 = s_1 \bind f$ if and only if for all $y\in s_2$, there exists an
$x \in s_1$ such that $y = f(x)$, and forall $x\in s_1$, $f(x)\in
s_2$. The encoding essentially adds new constraints to this effect.
The translation first encodes $s_1$ and $s_2$ to obtain
$(\phi_1,\G_1)$ and $(\phi_2,\G_2)$, respectively. Since $s_2$ is
under a new binder that binds $x$, the free variable sequence of $s_2$
is $\nubar,x$. In the interest of hygiene, we substitute a fresh $a$
for $x$, making the sequence $\nubar,a$. The set $s$ is encoded as a
new uninterpreted predicate $g$ indexed by $s$'s free variables
($\nubar$). Since the set denoted by $g$ is the result of the bind
$s_1 \bind \lambda x.s_2$, first-order constraints defining the bind
operation (as described above) are generated. The constraints relate
the predicates $\G_1$ and $\G_2$, representing $s_1$ and $s_2$
(resp.), to the uninterpreted predicate $g$ that represents $s$. The
constraints are assigned names ($\pi_1$ and $\pi_2$) to give them an
easy handle.

The first-order encoding of the $\existsl(\stg,\phi,s)$ expression
essentially Skolemizes the existential. Skolemizing is the
process of substituting an existentially bound $x$ in
$\phi_x\in\Prop^1$ with $f(\nubar)$, where $f$ is a fresh
uninterpreted function (called the Skolem function), and $\nubar$ are
the free variables in $\phi_x$ bound by enclosing universal
quantifiers. Due to the
decidability restrictions (Sec.~\ref{sec:decidability}), the only
uninterpreted functions we admit in our logic are boolean (i.e.,
predicates/relations). Consequently, we cannot define the Skolem
function $f$ directly. Instead, we define it via an uninterpreted
relation, by explicitly asserting the function property:
\begin{smathpar}
  \begin{array}{c}
    (\forall \nubar.\forall a.\forall b.~f(\nubar,a) \wedge f(\nubar,b)
    \Rightarrow a = b)
    ~~\conj~~ (\forall \nubar.\exists a. f(\nubar,a))
  \end{array}
\end{smathpar}
We then replace the existentially bound $\stg$ with a new universally
bound $a$ in $\phi$ and $s$, such that $f(\nubar,a) $ holds, before
encoding the existentially bound $s$.

\noindent {\bf Example} Let us reconsider the  TPC-C \C{new\_order}
transaction from Sec.~\ref{sec:motivation}. Recall that the state
transformer ($\T$) for the \C{foreach} loop shown in
Fig.~\ref{fig:foreach_code} is (\C{k1}, \C{k2}, and \C{k3} are
constants):
\begin{smathpar}
\begin{array}{l}
  \lambda(\stl,\stg).~ \stl \cup \C{item\_reqs}\bind
      (\lambda\C{item\_req}.~ \F_U(\stg) \cup \F_I(\stg))
\end{array}
\end{smathpar}
where:
\begin{smathpar}
  \begin{array}{lcl}
    \F_U & = & \lambda(\stg).~ \stg \bind(\lambda s. 
                \itel{{\sf table}(s) = \C{Stock} \conj 
                  s.\C{s\_i\_id} = \C{item\_req.ol\_i\_id}\\
         &   & \hspace*{0.8in}}
                     {\{ \langle \C{s\_i\_id}=s.\C{s\_i\_id};\, 
                                 \C{s\_d\_id}=s.\C{s\_d\_id};\,
                                 \C{s\_qty} = \C{k1}\rangle \}\\
         &   & \hspace*{0.8in}} {\emptyset}) \\
    \F_I & = & \lambda(\stg).~ \{\langle\C{ol\_o\_id}=\C{k2},\,
                 \C{ol\_d\_id}=\C{k3},\, \C{ol\_i\_id}=\C{item\_req.ol\_i\_id},\, 
                 \C{ol\_qty}=\C{item\_req.ol\_qty}\rangle\}\\
  \end{array}
\end{smathpar}
For any $\stg$, $\F_U(\stg)$ and $\F_I(\stg)$ are expressions in
$\SL$, so can be translated to FOL by the encoding algorithm in
Fig.~\ref{fig:logic}. Since the iteration variable \C{item\_req}
occurs free in these expressions, the appropriate application of the
encoding algorithm is $\mssemof{\C{item\_req}}{\F_U(\stg)}$ and
$\mssemof{\C{item\_req}}{\F_I(\stg)}$, which results in
$(\phi_U,\G_U)$ and $(\phi_I,\G_I)$, respectively, where $\phi_U$,
$\phi_I$, $\G_U$, $\G_I$ are as shown below:
\begin{smathpar}
  \begin{array}{lcl}
    \phi_U & = & \hspace*{0.2in}\forall \C{item\_req}.\forall s. \forall s'.~ 
        \pi_1(\C{item\_req}) \Leftrightarrow \\
    & & \hspace*{0.3in}(s \in \stg) \conj 
        (\itec{{\sf table}(s)=\C{Stock} \wedge 
              s.\C{s\_i\_id} = \C{item\_req.ol\_i\_id}\\
    & & \hspace*{0.85in}}
              {s' = \langle \C{s\_i\_id}=s.\C{s\_i\_id};\, 
                            \C{s\_d\_id}=s.\C{s\_d\_id};\,
                            \C{s\_qty} = \C{k1}\rangle\\
    & & \hspace*{0.85in}} {\bot}) \Rightarrow g_0(\C{item\_req},s')\\
    & & \conj \hspace*{0.08in}\forall \C{item\_req}.\forall s'. \exists s.~ 
        \pi_2(\C{item\_req}) \Leftrightarrow \\
    & & \hspace*{0.28in} g_0(\C{item\_req},s') \Rightarrow (s \in \stg) \conj
        (\itec{{\sf table}(s)=\C{Stock} \wedge 
              s.\C{s\_i\_id} = \C{item\_req.ol\_i\_id}\\
    & & \hspace*{1.8in}}
              {s' = \langle \C{s\_i\_id}=s.\C{s\_i\_id};\, 
                            \C{s\_d\_id}=s.\C{s\_d\_id};\,
                            \C{s\_qty} = \C{k1}\rangle\\
    & & \hspace*{1.8in}} {\bot}) \\
    \G_U & = & \lambda (\C{item\_req},r).~ \pi_1(\C{item\_req}) \wedge 
        \pi_2(\C{item\_req}) \wedge g_0(\C{item\_req},r)\\
        \phi_I & = & \top \\ 
    \G_I & = & \lambda (\C{item\_req},r).~ 
        r = \langle \C{ol\_o\_id}=\C{k2},\,
                    \C{ol\_d\_id}=\C{k3},\, 
                    \C{ol\_i\_id}=\C{item\_req.ol\_i\_id},\, 
                    \C{ol\_qty}=\C{item\_req.ol\_qty}
             \rangle\\
  \end{array}
\end{smathpar}
Since the transformer ($\T$) of the \C{foreach} loop is not nested
does not contain any free iteration variables, the appropriate
application of the encoding algorithm  is
$\mssemof{\emptyset}{\T(\stl,\stg)}$, which results in the
$(\phi,\G)$, as defined below:
\begin{smathpar}
  \begin{array}{lcl}
    \phi & = & \phi_I \conj \phi_U \conj \\
    & & \hspace*{0.2in}\forall \C{item\_req}. \forall s.~ 
        \pi_3 \Leftrightarrow (\C{item\_req} \in \C{item\_reqs} \conj 
        (\G_U(\C{item\_req},s') \vee \G_I(\C{item\_req},s'))
        \Rightarrow g_1(s))\\
    & & \conj \hspace*{0.05in}\forall s.\exists \C{item\_req}. ~ 
        \pi_4 \Leftrightarrow (g_1(s) \Rightarrow (\C{item\_req} \in \C{item\_reqs} 
        \conj (\G_U(\C{item\_req},s') \vee \G_I(\C{item\_req},s')))\\
    \G & = & \lambda(r).~\pi_3 \wedge \pi_4 \wedge g_1(r)\\
  \end{array}
\end{smathpar}


\subsection{Decidability}
\label{sec:decidability} %this label is referenced earlier.

Observe that the encoding shown in Fig.~\ref{fig:logic} maps to
a fragment of FOL that satisfies the following syntactic properties:
\begin{itemize}
  \item All function symbols, modulo those that are drawn from
    $\Prop^0$ and $\Prop^1$, are uninterpreted and Boolean.
  \item All quantification is first-order; second-order objects, such
    as sets and functions, are never quantified.
  \item Quantifiers appear only at the prenex position, i.e., at the
    beginning of a quantified formula.
\end{itemize}
The simple syntactic structure of the fragment already makes is
amenable for automatic reasoning via an off-the-shelf SMT solver, such
as Z3. The decidability of this fragment, however, is more subtle and
discussed below.

Consider a set expression $s$ with no free variables (i.e., $\nubar =
\emptyset$, like $\T(\stl,\stg)$ from the above example). Let
$(\phi,G) = \mssemof{\emptyset}{s}$. Note that $\phi$ is a conjunction
of (a).  $\phi_i$'s, where each $\phi_i$ results from encoding a
subexpression $s_i$ of $s$, and (b). a $\phi_s$, resulting from
encoding $s$ itself (i.e., its top-level expression). From Fig.~\ref{fig:logic},
it is clear that $\phi_s$ is either $\top$ (for the first four cases),
or it is a prenex-quantified formula, where quantification is either
$\forall^2$, or $\exists$, or $\forall\exists$. Generalizing this
observation, for a set expression $s$ with $|\nubar|$ free variables,
$\phi_s$, if quantified, is a prenex-quantified formula, where
quantification assumes one among the forms of $\forall^{|\nubar|+2}$,
or $\forall^{|\nubar|}\exists$, or $\forall^{|\nubar|+1}\exists$.  In
other words, the number of $\forall$ quantifiers preceding an
$\exists$ quantifier is utmost one more than the number of free
variables ($\nubar$) in $s$. For the convenience of this discussion,
let us call $\forall^{|\nubar|+1}\exists$ as the prenex signature of
$\phi_s$. 

Next, in Fig.~\ref{fig:logic}, observe that the (ordered) set $\nubar$
is extended only in the encoding rule for $\bind$. Since an occurrence
of $\bind$ adds a quantifier to $|\nubar|$, if $s$ is a bind
expression nested inside a top-level bind expression (like
$\F_U(\stg)$ from the above example), then the prenex signature
of $\phi_s$ is $\forall^2\exists$.  Furthermore, if the subexpressions
of $s$ are neither {bind} nor $\existsl$ expressions, then none of the
$\phi_i$'s are quantified, and the prenex signature of $\phi = \bigwedge_i\phi_i \wedge \phi_s$
remains $\forall^2\exists$. A similar
observation holds when $s$ is an $\existsl$ expression nested inside a
top-level {bind} expression.  Since $\existsl$ is generated as a
result of stabilizing a SQL command transformer, which is always a
non-nested bind expression, the subexpression ($s'$) of $\existsl$ is
a non-nested bind expression. $s'$ is however nested inside a
top-level bind expression, hence its prenex signature is
$\forall^2\exists$.  Since $\existsl$ doesn't extend $\nubar$, the
prenex signature of $s$ remains $\forall^2\exists$. When $s$ is an
expression other than $\bind$ or $\existsl$, then $\phi_s$ is not a
quantified formula, and its prenex signature is trivially subsumed by
$\forall^2\exists$. Thus, for the subset of $\SL$, where bind
expressions are restricted to one level of nesting, the FOL formulas
generated by the encoding have the prenex signature as
$\forall^2\exists$.

The fragment of FOL that admits formulas with prenex signatures of the
form $\forall^2\exists^*$ is called the G\"odel-K\'almar-Sch\"utte ({\sf
GKS}) fragment~\cite{gks}, which is known to be decidable. The
language of encoding, however, is a combination of {\sf GKS} with (a).
$\Prop^0$, the theory from which quantifier-free propositions
($\varphi$) that encode object language expressions are drawn, and
(b). $\Prop^1$, the theory from which invariants ($I$) are drawn. Thus,
the encoding of the subset of $\SL$ described above is decidable if the
combination of ${\sf GKS} + \Prop^0 + \Prop^1$ is decidable. We write
$\SL[\Prop^0,\Prop^1]$ to highlight the parameterization of $\SL$ on
$\Prop^0$ and $\Prop^1$.  The discussion in the previous paragraph
points to the existence of non-trivial subsets in $\SL[\Prop^0,\Prop^1]$ that are
decidable:
\begin{theorem}
  There exist $\SL'[\Prop^0,\Prop^1] \subset \SL[\Prop^0,\Prop^1]$
  such that $\SL'$ is decidable if ${\sf GKS}+\Prop^0+\Prop^1$ is
  decidable.
\end{theorem}
One interesting example of such an $\SL'$ is the subset described above: $\SL$ with
bind expressions confined to one level of nesting. We denote this
subset as $\SL^1[\Prop^0,\Prop^1]$, for which we assert decidability:
\begin{corollary}
  $\SL^1[\Prop^0,\Prop^1]$ is decidable if ${\sf GKS}+\Prop^0+\Prop^1$ is
  decidable.
\end{corollary}
$\SL^1$ is a useful subset of $\SL$, for it corresponds to $\txnimp$
programs without nested \C{foreach} loops. Observe that the
\C{new\_order} transaction (Fig.~\ref{fig:new_order_code}) belongs to
this subset.  Indeed, $\SL^1$, while being a restricted version of
$\SL$, is nonetheless expressive enough to cover all the benchmarks we
considered in Sec.~\ref{sec:case-studies}.

A useful instantiation of $\SL^1$ is $\SL[{\sf BV},{\sf GKS}+{\sf
BV}]$, where ${\sf BV}$ is the theory of bit-vector arithmetic, which
is often used to encode the finite-bit integer arithmetic of real
programs. Finite-bit integer arithmetic has a finite axiomatization in
{\sf GKS}. For instance, 32-bit integers can be encoded as $2^{32}$
distinct constants of an uninterpreted sort $T$, while integer
operations like addition and multiplication can be encoded as
uninterpreted functions whose properties are enumerated for the entire
domain of $T$. Thus {\sf BV} is subsumed by {\sf GKS}. Since the
latter is decidable, the combination is decidable:
\begin{theorem}
  $\SL^1[{\sf BV},{\sf GKS}+{\sf BV}]$ is decidable.
\end{theorem}
This instantiation requires $I$ to be drawn from {\sf GKS}+{\sf BV},
which is expressive enough to describe common database integrity
constraints, such as referential integrity, non-negativeness of all
integer values in a column etc.  The isolation specifications
presented in \S\ref{sec:isolation} are already simple first-order
formulas that can be encoded in {\sf GKS}.  Furthermore, it is also
reasonable to expect the guarantee ($G$) of a transaction to be
expressible in the same logic as its inferred $\F$, since $\F$
(without the stability check) is essentially a complete
characterization of the transaction, while $G$ is only an abstraction.
Thus, with $\SL^1[{\sf BV},{\sf GKS}+{\sf BV}]$ as the language of
inference, the verification problem for weakly isolated transactions
is decidable.

% This
% fragment of FOL known as EPR (Effectively Propositional
% logic) is
% known to be decidable~\cite{z3epr}. The language of encoding, however,
% is a combination of {\sf EPR} with (a). $\Prop^0$, the theory from
% which quantifier-free propositions ($\varphi$) that encode object
% language expressions are drawn, and (b).  $\Prop^1$, the theory from
% which invariants ($I$) are drawn. We write $\SL[\Prop^0,\Prop^1]$ to
% highlight the parameterization of $\SL$ on $\Prop^0$ and $\Prop^1$,
% and state the following theorem:
% \begin{theorem}
%   $\SL[\Prop^0,\Prop^1]$ is decidable if ${\sf EPR}+\Prop^0+\Prop^1$
%   is decidable.
% \end{theorem}
% A useful instantiation of $\SL$ is $\SL[{\sf SLA},{\sf EPR}+{\sf
% SLA}]$, where ${\sf SLA}$ is the theory of simple linear arithmetic.
% Since {\sf EPR}+{\sf SLA} is known to be decidable~\cite{eprsla}:
% \begin{theorem}
%   $\SL[{\sf SLA},{\sf EPR}+{\sf SLA}]$ is decidable.
% \end{theorem}
% The $\SL[{\sf SLA},{\sf EPR}+{\sf SLA}]$ instantiation requires $I$ to
% be drawn from {\sf EPR}+{\sf SLA}, which is expressive enough to
% describe common database integrity constraints, such as referential
% integrity, non-negativeness of all integer values in a column etc.
% The isolation specifications presented in \S\ref{sec:isolation} are
% already simple first-order formulas that can be encoded in {\sf EPR}.
% Furthermore, it is also reasonable to expect the guarantee ($G$) of a
% transaction to be expressible in the same logic as its inferred $\F$,
% since $\F$ (without the stability check) is essentially a complete
% characterization of the transaction, while $G$ is only an abstraction.
% Thus, with $\SL[{\sf SLA},{\sf EPR}+{\sf SLA}]$ as the language of
% inference, the verification problem for weakly isolated transactions
% is decidable. Moreover, off-the-shelf SMT solvers (e.g., Z3) are
% equipped with efficient decision procedures for ${\sf EPR}+{\sf SLA}$,
% making automated verification a practical exercise.

