\section{Inference}
\label{sec:inference}

The rely-guarantee framework presented in the previous section
facilitates modular proofs for weakly-isolated transactions, but
imposes a non-trivial annotation burden.  In particular, it requires
each statement ($c$) of the transaction to be annotated with a stable
pre- ($P$) and post-condition ($Q$), and loops to be annotated with
stable inductive invariants ($\psi$). While weakest pre-condition
style predicate transformers can help in inferring intermediate
assertions for regular statements, loop invariant inference remains
challenging, even for the simple form of loops considered here.  As an
alternative, we present an inference algorithm based on state
transformers that alleviates this burden.  The idea is to infer the
logical effect that each statement has on the transaction-local
database state $\stl$ (i.e., how it transforms $\stl$), and compose
multiple such effects together to describe the effect of the
transaction as a whole.  Importantly, this approach generalizes to
loops, where the effect of a loop can be inferred as a well-defined
function of the effect of its body, thanks to certain pleasant
properties enjoyed by the database programs modeled by $\txnimp$.
Interpreting database semantics as functional transformations on sets
(described in terms of their logical effects) enables an inference
mechanism that can leverage off-the-shelf SMT solvers for automated
verification.

\input{logic-syntax}

At the core of our approach is a simple language ($\SL$) to express
set transformations (see Fig.~\ref{fig:logic-syntax}). The language
admits only set expressions that include variables ($x$), literals of
the form $\{x \,|\, \varphi\}$ where $\varphi$ is a propositional
(quantifier-free) formula on $x$, a restricted form of existential
quantification that binds a set $x$ satisfying proposition $\phi$ in a
set expression $s$, a monadic composition of two set expressions
($s_1$ and $s_2$) composed using a bind ($\bind$) operation, a
conditional set expression where the condition is a propositional
formula, and a union of two set expressions. Symbols $\stl$ and $\stg$
are also variables in $\SL$, but are used to denote local and database
states, respectively. Constant sets can be written using the set
literal expressions. For e.g., the set $\{1,2\}$ can be written as
$\{x \,|\, x=1 \vee x=2\}$. The language is carefully chosen to be
expressive enough to capture the semantics of $\txnimp$ statements (as
well as SQL operations more generally), yet simple enough to have a
semantics-preserving translation to a decidable fragment of
first-order logic.
\input{inference-rules}
Fig.~\ref{fig:inference-rules} shows the syntax-directed state
transformer inference rules for $\txnimp$ commands inside a
transaction $\C{TXN}_i$.  Inference depends on the $\I$-constrained
rely relation $\R$, and the high-level invariant $I$ for the reasons
that will become clear shortly.  Inference rules compute, for each
command $c$, a (meta) function $\F$ that returns a set as an
expression in $\SL$, given a pair of sets ($\stl$ and $\stg$) that
describe local and a global database states, respectively. The
expression returned by $\F(\stl,\stg)$ (abstractly) describes the set
of records that get added to $\stl$ as a result of executing $c$ under
$\stl$ and $\stg$.  Thus, $\F$ captures the \emph{effect} part of the
state transformer of $c$, which is the function
$\lambda(\stl,\stg).~\stl \cup \F(\stl,\stg)$\footnote{Recall that the
  operational semantics treats deletion of records as the addition of
  the deleted record with its \C{del} field set to true in the local
  store.}. For $\F$ to be useful in RG verification, it needs to be
stable w.r.t the rely relation $\R$. The stability condition on
effects can be defined thus:
\begin{smathpar}
\begin{array}{lcl}
  \stable(\R,\F) & \Leftrightarrow & \forall \stl,\stg,\stg',\nubar.~
  \R(\stl,\stg,\stg') \Rightarrow \F(\stl,\stg) \equiv \F(\stl,\stg')
\end{array}
\end{smathpar}
where $\nubar$ are the variables that occur free in $\F$; this is
possible because of how the inference rules are structured.
Intuitively, the stability condition requires an effect to describe
the same set of records before and after the interference. The
equivalence in $\SL$ translates to equality in first-order logic,
as we describe below. In the inference rules, stability is
enforced constructively by a meta function $\stabilize{\cdot}$, which
accepts an effect and returns a new effect that is guaranteed to be
stable under $\R$.  $\stabilize{\cdot}$ achieves the stability
guarantee by abstracting away the bound $\stg$ in an unstable $\F$ to
an existentially bound $\stg'$ as described below:
\begin{smathpar}
\begin{array}{lcll}
  \stabilize{\F} & = & \F & \texttt{if } \stable(\R,\F).\\
  & = & \lambda (\stl,\stg).~\existsl(\stg',I(\stg'),\F(\stl,\stg')) 
      & \texttt{otherwise. }\stg'\texttt{ is a fresh name.}\\
\end{array}
\end{smathpar}
Observe that when $\F$ is not stable, then $\stabilize{\F}$ returns a
transformer $\F'$ that simply ignores its $\stg$ argument in favor of
a generic $\stg'$, making $\F'$ trivially stable. It is safe to assume
$I(\stg')$ because all verified transactions preserve the invariant,
and hence only valid database states will ever be witnessed. From the
perspective of RG reasoning, $\stabilize{\cdot}$ effectively weakens
the post-condition of a statement, as done by the
\rulelabel{RG-Conseq} rule for transaction-bound commands.  The
weakening semantics chosen by $\stabilize{\cdot}$, while being simple,
is nonetheless useful because of the $I(\stg')$ assumption on the
existentially bound $\stg'$. The example in
Fig.~\ref{fig:weakening-example} demonstrates. 
\begin{figure}[h]
\begin{center}
\begin{ocaml}
let add_interest acc_id pc = atomically_do @@ fun () ->
  let a = SQL.select1 BankAccount (fun acc -> acc.id = acc_id) in
  let y = a.bal + pc*a.bal in
  SQL.update BankAccount (fun acc -> {acc with bal = acc.bal + y})
                         (fun acc -> acc.id = acc_id)
\end{ocaml}
\end{center}
\caption{A transaction that deposits an interest to a bank account.}
\label{fig:weakening-example}
\end{figure}
Here, an \C{add\_interest} transaction adds a positive interest
(determined by \C{pc}) to the balance of a bank account, which is
required to be non-negative ($I(\stg) \Leftrightarrow
\forall(r\in\stg).~r.\C{bal}\ge 0$). The transaction starts by issuing
a \C{select1} query, whose effect ($\F$) is essentially a singleton
set containing a record $r$ whose id is \C{acc\_id} (i.e.,
$\F(\stl,\stg) = \{r \,|\, r\in\stg \wedge r.\C{id} = \C{acc\_id}\}$).
However, this effect is unstable because $\F(\stl,\stg')$ may not be
the same set as $\F(\stl,\stg)$ when $\stg'\neq\stg$. A record
$r\in\stg$ whose $\C{id}=\C{acc\_id}$ may have its balance updated by
a concurrent \C{withdraw} or \C{deposit} transaction in $\stg'$,
making the record in $\stg'$ different from the record in $\stg$.
Hence the stability check fails.  Fortunately, the weakening operator
($\stabilize{\cdot}$) allows us to weaken the effect to
$\existsl(\stg, I(\stg), \{ r \,|\, r\in\stg \wedge
r.\C{id}=\C{acc\_id}\})$, which effectively asserts that the
\C{select1} query returns a record with $\C{id}=\C{acc\_id}$ from
\emph{some} database state that satisfies the non-negative balance
invariant $I$.  This weakened assertion is nonetheless enough to
deduce that $\C{a.bal}\ge0$, and subsequently prove that $\C{a.bal +
pc*a.bal}\ge 0$, allowing us to verify the \C{add\_interest}
transaction.

The state transformer rules, like the earlier RG rules, closely follow
the corresponding reduction rules in Fig.~\ref{fig:txnimp}, except
that their language of expression is $\SL$. For instance, while the
reduction rule for \C{UPDATE} declaratively specifies the set of
updated records, the state transformer rule uses $\SL$'s bind
operation to \emph{compute} the set. Other SQL rules do likewise. The
rules for \C{LET} binders, conditionals, and sequences compose the
effects inferred for their subcommands. Thus, the effect of a sequence
of commands $c_1;c_2$ is the union of effects $F_1$ and $F_2$ of $c_1$
and $c_2$, respectively, except that $F_2$ is applied to a state
($\stl$) to which $F_1$ has already been applied, reflecting their
order of reduction. The inference rule for \C{FOREACH} takes advantage
of the $\SL$'s bind operator to lift the effect inferred for the loop
body to the level of the loop. Since records added to $\stl$ in each
iteration of \C{FOREACH} are independent of the previous iteration (the
rule assumes local context independence as discussed in \S\ref{sec:opsem}),
the sequential composition of the effects of different iterations is the same
as their parallel composition. Since the loop body is executed once
per each $z\in x$, the effect of the the loop is the union of effects
($\F$) for all $z\in x$, all applied to the same state ($\stl$ and
$\stg$). That is, $\F_{loop}(\stl,\stg) = \bigcup_{z\in
  x}\F_{body}(\stl,\stg)$. From the definition of the set monad's bind
operator, $\F_{loop}(\stl,\stg) = x \bind (\lambda
z.~F_{body}(\stl,\stg))$, which mirrors the definition of the rule.
%This development mirrors ideas found in type checkers for certain
%dependent type systems~\cite{KJ14}.


% \begin{figure}[h]
% \begin{smathpar}
% \begin{array}{l}
%   \foreache{xs}{(\lambda y.\lambda x.~ 
%         \updatee{(\lambda z.~ \{\idf=z.\idf;\,\C{name}=z.\C{name};\,
%                                \C{s\_id}=x.\idf\})}
%                 {(\lambda z.~ z.\idf = x.\C{s\_id})};\\
%         \hspace*{1.27in} \inserte{x})}
% \end{array}
% \end{smathpar}
% \caption{A $\txnimp$ program that populates a database
%   of couples.}
% \label{fig:people_code}
% \end{figure}

%% \begin{example}
%% Consider a database of couples that tracks the spouse
%% relationship. Each record has an $\idf$ field, a \C{name} field, and a
%% spouse id (\C{s\_id}) field. A $\txnimp$ transaction bearing id $i$
%% that populates the database with a given set ($xs$) of couples will
%% include the following code snippet:
%% \begin{smathpar}
%% \begin{array}{l}
%%   \foreache{xs}{(\lambda y.\lambda x.~ 
%%         \updatee{(\lambda z.~ \{\idf=z.\idf;\,\C{name}=z.\C{name};\,
%%                                \C{s\_id}=x.\idf\})}
%%                 {(\lambda z.~ z.\idf = x.\C{s\_id})};\\
%%         \hspace*{1.27in} \inserte{x})}
%% \end{array}
%% \end{smathpar}
%% The effect captured by a state transformer inferred for the program, assuming no interference would be:
%% \begin{smathpar}
%% \begin{array}{l}
%%   \lambda(\stl,\stg).~xs \bind 
%%     (\lambda x. \stg \bind 
%%       (\lambda z. \itel{z.\idf = x.\C{s\_id}}
%%                        {\{\{\idf=z.\idf;\,\C{name}=z.\C{name};\,
%%                                \C{s\_id}=x.\idf\}\}}
%%                        {\emptyset}) \\
%%       \hspace*{1cm} ~\cup~ \{y \,|\, y = \{x \with \delf=\mathit{false}; \}\})
%% \end{array}
%% \end{smathpar}
%% Under the possibility of an interference affecting the stability, the
%% following stable effect is inferred ($I$ is the database invariant):
%% \begin{smathpar}
%% \begin{array}{l}
%%   \lambda(\stl,\stg).~xs \bind 
%%     (\lambda x.~\existsl(\stg',I,\stg' \bind 
%%       (\lambda z. \itel{z.\idf = x.\C{s\_id}}
%%                        {\{\{\idf=z.\idf;\,\C{name}=z.\C{name};\,
%%                                \C{s\_id}=x.\idf\}\}}
%%                        {\emptyset})) \\
%%       \hspace*{1cm} ~\cup~ \{y \,|\, y = \{x \with \delf=false; \}\})
%% \end{array}
%% \end{smathpar}
%% \end{example}

\subsection{Soundness of Inference}

We can now establish a correspondence between the inference rules given
above and the RG judgment of \S\ref{sec:reasoning}:
\begin{theorem}
  \label{thm:inference-sound}
  Let the set expression $\F(\emptyset,\stg)$ have a natural interpretation
  in the theory of sets.  Then, for all $i$,$R$,$I$,$c$,$\F$,
  if $\stable(\R,I)$ and $c \elabsto \F$,
  then:\\\vspace*{-0.2cm}
  \begin{smathpar}
  \begin{array}{c}
  \R \vdash \hoare{\lambda(\stl,\stg).~\stl=\emptyset \conj
  I(\stg)}{c}{\lambda(\stl,\stg).\stl = \F(\emptyset,\stg)}
  \end{array}
  \end{smathpar}
\end{theorem}

\paragraph{{\sc Proof Sketch.}} We prove a slightly stronger statement :
For all  $i$,$R$,$I$,$c$,$\F$,$s$ if $\stable(\R,I)$ and $c \elabsto \F$, then:
  \begin{smathpar}
    \begin{array}{c}
    \R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
    I(\stg)}{c}{\lambda(\stl,\stg).\stl = \F(s,\stg)}
    \end{array}
  \end{smathpar}
The proof follows by structural induction on $c$. Assume that $P
\Leftrightarrow \lambda(\stl,\stg).~\stl=s \conj I(\stg)$ and $Q
\Leftrightarrow \lambda(\stl,\stg).\stl = \F(s,\stg)$. For each type
of $c$, our strategy is to show the premises of the corresponding
RG-rule. The base cases correspond to \C{INSERT}, \C{UPDATE} and \C{DELETE}
statements. In all these cases, the form of $\F$ directly corresponds
to the condition linking the pre-condition $P$ and post-condition $Q$
in the premises of the RG-rules. If $\stable(\R, \F)$, then
$\stabilize{\F} = \F$ and hence the proof directly follows. Otherwise,
$\stabilize{\F} = \lambda (\stl, \stg).\existsl(\stg', I(\stg'),
\F(\stl, \stg'))$. Since the pre-condition $P(\stl, \stg)$ asserts
$I(\stg)$, any state which obeys $P$ provides the existential $\stg'$
in the above set expression, and hence $\F$ applied on that state
matches the condition linking $P$ and $Q$. The stability of $P$ with
respect to $\R$ follows directly from the stability of $I$.

The proofs for \C{SELECT}, sequencing, and conditionals use use the
inductive hypothesis to infer the RG-judgments present in the
premises of their corresponding RG-rules. The interesting case is the
\C{FOREACH} statement, for which we use the loop invariant
$\psi(\stl, \stg) \Leftrightarrow \stl = s \cup (y \bind (\lambda
z.~\F(s, \stg)))$, (where assuming that $c$ is the body of the loop,
$c \elabsto \F$) to prove all the premises of
\rulelabel{RG-Foreach}. Using the same notation as the rule
$\rulelabel{RG-Foreach}$, $y$ refers to the records already processed
in previous iterations of the loop, while $z$ refers to the record
being processed in the current iteration.  At the beginning of the
loop $[\phi/y]\psi(\stl, \stg)$ just reduces to $\stl = s$ which is
implied by the pre-condition $P$. From the inductive hypothesis, we
can infer that each iteration corresponds to the application of
$F$. Since all iterations are assumed to be independent of each other,
and $z$ is bound to a record in $x$ for each iteration, we conclude
that at the end of every iteration, the loop invariant $[y \cup
  \{z\}/y]\psi$ will be satisfied.

\subsection{From $\SL$ to the first-order logic}

\input{logic}

Theorem~\ref{thm:inference-sound} lets us replace the local judgment
of the \rulelabel{RG-Txn} rule (Fig.~\ref{fig:rg-rules}) by a state
transformer inference judgment. The soundness of a transaction's
guarantee can now be established w.r.t the effect $\F$ of the body.
The \rulelabel{RG-Txn} rule so updated is shown below:
\begin{smathpar}
\begin{array}{c}
\RULE
{
   \stable(R,\I)\spc
   \stable(R,I)\\
   \R_e = R \backslash \I_e \spc \R_c = R \backslash \I_c \spc  
   c \elabsto \F \spc \stable(\R_c,\F)\\
   \forall \stl,\stg.~ \stl = F(\emptyset,\stg) \Rightarrow 
   G(\stg, \stl\gg\stg)\spc
   \forall \stg,\stg'.~I(\stg) \wedge G(\stg,\stg') \Rightarrow I(\stg')\\
}
{
  \rg{I,R}{\ctxn{i}{\I}{c}}{G,I}
}
\end{array}
\end{smathpar}
% \begin{smathpar}
% \begin{array}{c}
% \RULE
% {
%   \stable(R,\I)\spc
%   \stable(R,I)\spc
%   P(\stl,\stg) \Leftrightarrow \stl=\emptyset \wedge I(\stg)\\
%   \R_e = R \backslash \I_e \spc \R_c = R \backslash \I_c \spc 
%    \R_e \vdash \rg{P}{c}{Q} \spc \stable(\R_c,Q) \\ 
%   \forall \stl,\stg.~ Q(\stl,\stg) \Rightarrow 
%     G(\stg, \stl \rhd \stg)\spc
%   \forall \stg,\stg'.~I(\stg) \wedge G(\stg,\stg') \Rightarrow I(\stg')\\
% }
% {
%   \rg{I,R}{\ctxn{i}{\I}{c}}{G,I}
% }
% \end{array}
% \end{smathpar}
Automating the application of the \rulelabel{RG-Txn} rule for a
transaction requires automating the multiple implication checks in
the premise. While $R$, $G$, $\I$ and $I$ are formulas in
first-order logic (FOL) with a relatively simple structure, $\F$
is an expression in the set language $\SL$
(Fig.~\ref{fig:logic-syntax}) with a possibly complex structure.
Fortunately, however, there exists a semantics-preserving translation
from $\SL$ to a restricted subset of first-order logic (FOL) that
lends itself to automatic reasoning. 

The algorithm ($\mssemof{\cdot}{\cdot}$) shown in Fig.~\ref{fig:logic}
translates an $\SL$ expression ($s$) to FOL. The translation is based
on encoding a set of element type $T$ as a unary predicate on $T$.
The predicate is represented as a meta function that accepts an $x:T$
and returns a quantifier-free proposition that evaluates to true
($\top$) if and only if $x$ is present in the set. Alternatively,
translation may also encode the set as a predicate in the logic
itself, in which case a quantified proposition constraining the
predicate is also generated. For instance, consider the set $\{1,2\}$.
The predicate describing the set can be encoded as the function
$\lambda \v. \v=1 \vee \v=2$, with no further constraints, or it can
be encoded as the function $\lambda \v. g(\v)$ with an associated
constraint ($\phi\in\Prop^1$) defining the uninterpreted boolean
function (i.e., uninterpreted predicate) $g$:
\begin{smathpar}
  \begin{array}{lcl}
    \phi & = & \forall \nu.~g(\nu) \Leftrightarrow \nu=1 \vee \nu=2
  \end{array}
\end{smathpar}
The translation adopts one or the other approach, depending on the
need. For uniformity, we consider the encoding of a set as pair
($\phi$,$\G$), where $\G$ is a meta function, and $\phi$ is a FOL
formula constraining any uninterpreted predicates used in $G$.

Due to the presence of bind ($\bind$) in $\SL$, a set expression $s$
may contain free variables introduced by an enclosing binder. For
instance, consider the $\SL$ expression $s_1\bind(\lambda x. \{ y\,|\,
y=x+1\})$, where $s_1$ is an integer set (expression). The
subexpression $\{ y\,|\, y=x+1\}$ (call it $s_2$) contains $x$ as a
free variable. In such cases, the predicate associated with the
subexpression should also be indexed by its free variables, so that a
unique set exists for each instantiation of the free variables. Thus,
the predicate ($\G$) associated with the subexpression from the
above example should be $\lambda\v_1.\lambda\v_2.~\v_2 = \v_1 + 1$, so
that the set $\G\; x_1$ is different from the set $\G\; x_2$ for
distinct $x_1,x_2 \in s_1$. Intuitively, the bind expression
$s_1\bind(\lambda x. \{ y\,|\, y=x+1\})$ denotes the set
$\bigcup\limits_{x\in s_1}\G\;x$.

The translation algorithm (Fig.~\ref{fig:logic}) takes free variables
into account. Given a set expression $s\in\SL$, whose (possible) free
variables are $\nubar$ in the order of their introduction (top-most
binder first), $\mssemof{\nubar}{s}$ returns the encoding of $s$ as
$(\phi,\G)$.  The meta function $\G$ is a predicate indexed by the
(possible) free variables of $s$, thus, its arity is $|\nubar| + 1$.
Note that $\nubar$ is only a sequence of variables introduced by the
enclosing binders of $s$, and not all may actually occur free in $s$.
Nonetheless, its predicate $\G$ is always indexed by $|\nubar|$ free
variables for uniformity. The translation encodes database state as an
uninterpreted sort. Considering that the state is actually a set of
records, we define an uninterpreted relation ``$\in$'' to relate records
and states. Thus, a variable set expression $\stg$ denoting a database
state is encoded as the predicate $\lambda (\vbar,r).~r\in\stg$, where
$|\vbar|=|\nubar|$ (predicates are uncurried for simplicity; $\vbar$
is a comma-separated sequence; $r\not\in\SL$ is a special variable).
The constraints associated with the encoding of a state are trivial
(denoted $\top$). The set literal expression $\{x\,|\, \varphi\}$ is encoded
straightforwardly. The conditional set expression is encoded as an
if-then-else predicate in FOL, where the predicates on true and false
branches are computed from the set subexpressions $s_1$ and $s_2$,
respectively. The conjunction of constraints $\phi_1$ and $\phi_2$,
from $\mssemof{\nubar}{s_1}$ and $\mssemof{\nubar}{s_2}$ (resp.), is
propagated upwards as the constraint of the conditional expression.
Set union expression is encoded similarly.

The first-order encoding of a bind expression describes the semantics
of the set monad's bind operator in FOL. Let $s_1$ be a set, and let $f =
\lambda x.~s_2$ be a function that maps each variable in $s_1$ to a
new set. Then, $s = s_1 \bind f$ if and only if forall $x$, $y$, if
$x\in s_1$ and $y \in f(x)$, then  $y \in s$, and vice versa. The
translation first encodes $s_1$ and $s_2$ to obtain $(\phi_1,\G_1)$
and $(\phi_2,\G_2)$, respectively. Since $s_2$ is under a new binder
that binds $x$, the free variable sequence of $s_2$ is $\nubar,x$. In the
interest of hygiene, we substitute a fresh $a$ for $x$, making the
sequence $\nubar,a$. The set $s$ is encoded as a new uninterpreted
predicate $g$ indexed by $s$'s free variables ($\nubar$). Since the
set denoted by $g$ is the result of the bind $s_1 \bind \lambda
x.s_2$, a first-order constraint defining the bind operation (as
described above) is generated. The constraint relates the predicates
$\G_1$ and $\G_2$, representing $s_1$ and $s_2$ (resp.), to the
uninterpreted predicate $g$ that represents $s$. The constraint is
assigned a name ($\pi$) so that it can be enabled only for the choice
of free variables ($\nubar$) for which $g$ needs to be defined;
observe that the lambda expression returned by $\mssemof{\nubar}{s_1 \bind
\lambda x.s_2}$ asserts $\pi(\vbar)$ only in conjunction with
$g(\vbar,r)$, for some $r$.

The first-order encoding of the $\existsl(\stg,\phi,s)$ expression
eliminates the existential by Skolemizing it. Skolemizing is the
process of substituting an existentially bound $x$ in
$\phi_x\in\Prop^1$ with $f(\nubar)$, where $f$ is a fresh
uninterpreted function, and $\nubar$ are the free variables in
$\phi_x$ bound by enclosing universal quantifiers. Due to the
decidability restrictions (Sec.~\ref{sec:decidability}), the only
uninterpreted functions we admit in our logic are boolean (i.e.,
predicates/relations). Consequently, Skolemizing an existentially
bound $\stg$ with $f(\nubar)$ is not really an option in our case.
Instead, we define $f$ as an uninterpreted relation that behaves as a
partial function:
\begin{smathpar}
  \begin{array}{c}
    \forall \nubar.\forall a.\forall b.~f(\nubar,a) \wedge f(\nubar,b)
    \Rightarrow a = b
  \end{array}
\end{smathpar}
We then replace the existentially bound $\stg$ with a new universally
bound $a$ in $\phi$ and $s$, and define the set $[a/\stg]s$ under the
condition that $f(\nubar,a) \conj [a/\stg]\phi$ holds. Since the
existence of a $\stg$ that satisfies $\phi$ is axiomatized to
define $s$, if the aforementioned condition does not hold, i.e., if
there does exist such a $\stg$, we let the context derive $\bot$.

\noindent {\bf Example} Let us reconsider the  TPC-C \C{new\_order}
transaction from Sec.~\ref{sec:motivation}. Recall that the state
transformer for the \C{foreach} loop shown in
Fig.~\ref{fig:foreach_code} is (\C{k1}, \C{k2}, and \C{k3} are
constants):
\begin{smathpar}
\begin{array}{l}
  \lambda(\stl,\stg).~ \stl \cup \C{item\_reqs}\bind
      (\lambda\C{item\_req}.~ \F_U(\stl,\stg) \cup \F_I(\stl,\stg))
\end{array}
\end{smathpar}
where:
\begin{smathpar}
  \begin{array}{lcl}
    \F_U & = & \lambda(\stl,\stg).~ \stg \bind(\lambda s. 
                \itel{{\sf table}(s) = \C{Stock} \conj 
                  s.\C{s\_i\_id} = \C{item\_req.ol\_i\_id}\\
         &   & \hspace*{0.9in}}
                     {\{ \langle \C{s\_i\_id}=s.\C{s\_i\_id};\, 
                                 \C{s\_d\_id}=s.\C{s\_d\_id};\,
                                 \C{s\_qty} = \C{k1}\rangle \}\\
         &   & \hspace*{0.9in}} {\emptyset}) \\
    \F_I & = & \lambda(\stl,\stg).~ \{\langle\C{ol\_o\_id}=\C{k2},\,
                 \C{ol\_d\_id}=\C{k3},\, \C{ol\_i\_id}=\C{item\_req.ol\_i\_id},\, 
                 \C{ol\_qty}=\C{item\_req.ol\_qty}\rangle\}\\
  \end{array}
\end{smathpar}
For any $\stl$ and $\stg$, $\F_U(\stl,\stg)$ and $\F_I(\stl,\stg)$ are
expressions in $\SL$, so can be translated to FOL by the encoding
algorithm in Fig.~\ref{fig:logic}. Since the iteration variable
\C{item\_req} occurs free in these expressions, the appropriate
application of the encoding algorithm is
$\mssemof{\C{item\_req}}{\F_U(\stl,\stg)}$ and
$\mssemof{\C{item\_req}}{\F_I(\stl,\stg)}$, which results in
$(\phi_U,\G_U)$ and $(\phi_I,\G_I)$, respectively, where $\phi_U$,
$\phi_I$, $\G_U$, $\G_I$ are as shown below:
\begin{smathpar}
  \begin{array}{lcl}
    \phi_U & = & \forall \C{item\_req}.\forall s. \forall s'.~  \\
    & & \hspace*{0.1in}\pi(\C{item\_req}) \Leftrightarrow(s \in \stg) \conj 
        (\itec{{\sf table}(s)=\C{Stock} \wedge 
              s.\C{s\_i\_id} = \C{item\_req.ol\_i\_id}\\
    & & \hspace*{1.45in}}
              {s' = \langle \C{s\_i\_id}=s.\C{s\_i\_id};\, 
                            \C{s\_d\_id}=s.\C{s\_d\_id};\,
                            \C{s\_qty} = \C{k1}\rangle\\
    & & \hspace*{1.45in}} {\bot}) \\
    & & \hspace*{1.2in} \Leftrightarrow g(\C{item\_req},s')\\
    \G_U & = & \lambda (\C{item\_req},r).~ \pi(\C{item\_req}) 
        \wedge g(\C{item\_req},r)\\
    \phi_I & = & \top \\ 
    \G_U & = & \lambda (\C{item\_req},r).~ 
        r = \langle \C{ol\_o\_id}=\C{k2},\,
                    \C{ol\_d\_id}=\C{k3},\, 
                    \C{ol\_i\_id}=\C{item\_req.ol\_i\_id},\, 
                    \C{ol\_qty}=\C{item\_req.ol\_qty}
             \rangle\\
  \end{array}
\end{smathpar}

\subsection{Decidability}
\label{sec:decidability} %this label is referenced earlier.

Observe that the encoding shown in Fig.~\ref{fig:logic} maps to
a subset of logic that satisfies the following syntactic properties:
\begin{itemize}
  \item All quantification is first-order; second-order objects, such
    as sets and functions, are never quantified.
  \item All quantifiers are universal, and appear only at the prenex
    position, i.e., at the beginning of a quantified formula.  
  \item All function symbols, modulo those that might appear in
    $\varphi\in\Prop^0$, are uninterpreted and Boolean.
\end{itemize}
This fragment of FOL known as EPR (Effectively Propositional logic) is
known to be decidable~\cite{z3epr}. The language of encoding, however,
is a combination of {\sf EPR} with (a). $\Prop^0$, the theory from
which quantifier-free propositions ($\varphi$) that encode object
language expressions are drawn, and (b).  $\Prop^1$, the theory from
which invariants ($I$) are drawn. We write $\SL[\Prop^0,\Prop^1]$ to
highlight the parameterization of $\SL$ on $\Prop^0$ and $\Prop^1$,
and state the following theorem:
\begin{theorem}
  $\SL[\Prop^0,\Prop^1]$ is decidable if ${\sf EPR}+\Prop^0+\Prop^1$
  is decidable.
\end{theorem}
A useful instantiation of $\SL$ is $\SL[{\sf SLA},{\sf EPR}+{\sf
SLA}]$, where ${\sf SLA}$ is the theory of simple linear arithmetic.
Since {\sf EPR}+{\sf SLA} is known to be decidable~\cite{eprsla}:
\begin{theorem}
  $\SL[{\sf SLA},{\sf EPR}+{\sf SLA}]$ is decidable.
\end{theorem}
The $\SL[{\sf SLA},{\sf EPR}+{\sf SLA}]$ instantiation requires $I$ to
be drawn from {\sf EPR}+{\sf SLA}, which is expressive enough to
describe common database integrity constraints, such as referential
integrity, non-negativeness of all integer values in a column etc.
The isolation specifications presented in \S\ref{sec:isolation} are
already simple first-order formulas that can be encoded in {\sf EPR}.
Furthermore, it is also reasonable to expect the guarantee ($G$) of a
transaction to be expressible in the same logic as its inferred $\F$,
since $\F$ (without the stability check) is essentially a complete
characterization of the transaction, while $G$ is only an abstraction.
Thus, with $\SL[{\sf SLA},{\sf EPR}+{\sf SLA}]$ as the language of
inference, the verification problem for weakly isolated transactions
is decidable. Moreover, off-the-shelf SMT solvers (e.g., Z3) are
equipped with efficient decision procedures for ${\sf EPR}+{\sf SLA}$,
making automated verification a practical exercise.

