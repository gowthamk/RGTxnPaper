We thank the reviewers for their valuable feedback.

Reviewer (1):
-------------

- No support for Read Uncommitted (RU) isolation.  While RU is a valid
  ANSI SQL isolation level, it is typically not implemented by modern
  databases. For example, Oracle supports only RC and SER, while
  Postgres maps RU to RC. Even when RU is supported, it is never the
  default isolation level (Bailis et al, HotOS'13)., and applications
  rarely demote isolation levels to RU in practice (Bailis et al,
  SIGMOD'15). Thus, RC can be considered as a baseline isolation level
  that meets the performance demands of real-world applications.
  Furthermore, RU violates atomicity, the basic tenet underlying
  transactions.  Given its lack of acceptance in the database
  community, and the complications it would introduce to our
  formalization, we opted to elide it from the development.

- Limited set of operations in the DSL.  While it is true our language
  only includes four basic SQL operations, they have proven sufficient
  to implement widely accewpted standard benchmarks, such TPC-C and
  TPC-E.  We also note that MySQL's developer documentation (see:
  ....) indicates that its core calculus for SQL is indeed
  composed of these four basic operations, making our technique likely
  applicable on MySQL's core language, if not its surface language. We
  expect similar conclusions to hold on other databases.

Reviewer (2):
-------------

- Not admitting valid snapshot isolation (SI) executions.  We believe
  the reviewer has misunderstood our specification for SI as $I_{ss}$,
  which only describes the semantics of "executing against a
  snapshot". SI indeed executes against a snapshot (thus its $I_e =
  I_{ss}$), but it *commits* against any non-write-write-conflicting
  database state (thus its $I_c = I_{ww}$). This is explained on p.13
  ("Snapshot Isolation").  The presented specification indeed allows
  non-conflicting concurrent transactions to commit in parallel.

- Decidability.  (a) The RG-TXN (Sec. 5.2, p. 20) rule does not lead
  to second-order quantification or inversion of quantifier positions.
  First, recall that each premise of the rule generates an independent
  verification condition (VC) dispatched to the solver. The VC
  corresponding to $\mathbf{F}\Rightarrow G$ first introduces $\delta$
  and $\Delta$ into the context as some sets (uninterpreted
  functions).  Next, it asserts the logical encoding of $F$ computed
  using the rules in Fig.10. Finally it asserts the negation of $G$,
  and checks for satisfiability. Note that in this process: (i). sets
  or functions are never quantified (thus no second-order
  quantification), and (ii). $\mathbf{F}$ is never negated (thus no
  inversion of quantifiers in $\mathbf{F}$). Other premises are
  similarly encoded.

  The reviewer is correct in observing that our encoding is not in the
  EPR fragment of FOL since we admit formulas of the form $\forall
  x.\exists y.\phi$.  However, our encoding is still decidable as it
  belongs to a closely related variant of EPR, Godel-Kalmar-Schutte,
  that admits sentences of the form: $\exists^{}\forall^{2}\exists^{}$
  (see: Borger et al, The Classical Decision Problem, p.261; Gurevich,
  On the Classical Decision Problem, p.7); formulas generated by our
  encoding clearly belong to this fragment.  We will clarify this
  issue in the final version.

Reviewer (3);
-------------

- Dealing with heap state: It is indeed true that we have ignored heap
  memory to focus exclusively on database state in our
  formalization. Swamy et al. (PLDI'13), however, have proposed the
  Dijkstra monad to reason about heap memory monadically.  As part of
  future work, we intend to explore the composition of the DB and
  Dijkstra monads to enable reasoning over both heap and database
  state.
