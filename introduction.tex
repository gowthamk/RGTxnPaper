\section{Introduction}

Database transactions allow users to group operations on multiple
objects into a coherent unit with useful properties including
atomicity, consistency, (serializable) isolation and durability
(ACID). ACID has been the gold standard for database transactions for
many decades, providing programmers with a simple
implementation-independent model to reason about concurrent
transactions. However, serializability, the ACID-prescribed standard for
isolation, does not come for free; it requires databases to rely on
expensive techniques such as two-phase locking~\cite{twopl,ullmanbook}
that severely restrict concurrency while incurring an additional
overhead of deadlock detection, rollback and re-execution. Enforcing
serializability in a replicated data store requires global
coordination among geo-distributed replicas, which makes the store
\emph{unavailable} in presence of the inevitable network
partitions~\cite{cap,sernotavlbl,bailishat,bernsigmod13}. The
conflict between serializability and pragmatic goals of high
peformance and availability has motivated the development of multiple
weaker forms of transaction isolation beginning as early as
1976~\cite{gray1976}. ANSI SQL 92 standard defines three such weak
isolation \emph{levels} which are now implemented in
many relational and NoSQL databases. Weakly isolated transactions have
been found to significantly outperform serializable transactions on
benchmark suites, both on single-node~\cite{dbtuningbook} and
multi-node replicated stores~\cite{bailishat,bailisvldb}, leading to
their overwhelming adoption. A 2013 study~\cite{bailishotos} of 18
popular ACID and ``NewSQL'' databases found that only 3 of them offer
serializability by default, and half, including Oracle 11g, do not
offer it at all.  A 2015 study~\cite{bailisferal} of a large corpus of
database applications finds no evidence of any of them changing the
default isolation level offered by the database. Together, the studies
establish the prevalance of weak isolation in practice.

Unfortunately, weak isolation introduces new set of behaviors into
programs that often give rise to anomalous executions and
incomprehensible results~\cite{pldi15}. To quantify weak isolation
anomalies, Fekete et al~\cite{feketevldb09} have devised and
experimented with a microbenchmark suite that executes transactions
under \iso{Read Committed} isolation level - the default level for 8
of the 18 databases studied in~\cite{bailishotos}, and found that 25
out of every 1000 rows in the database violate at least one integrity
constraint. Bailis et al~\cite{bailisferal} rely on Rails's
\emph{uniqueness validation} to maintain uniqueness of records while
serving Linkbench's~\cite{linkbench} insertion workload (6400 records
distributed over 1000 keys; 64 concurrent clients), and end up with
more than 10 duplicate records. Rails relies on database transactions
to validate uniqueness during insertions, which is ok if transactions
are serializable, but incorrect under \iso{Read Committed} isolation
used in the experiments. The same study has found that 13\% of all
invariants among 67 open source Ruby-on-Rails applications are the
risk of being violated due to weak isolation. The ill effects of weak
isolation are therefore as prevalent as weak isolation itself.

The root cause of problems with weak isolation is that its semantics
in context of user programs is not well-understood. The original
proposal~\cite{gray1976} defines multiple ``degrees'' of weak
isolation in terms of implementation details, such as the nature and
duration of locks held in each case. ANSI SQL 92 standard four levels
of isolation (including serializability) in terms of sevaral
undesirable \emph{phenomena} (\eg \emph{dirty reads}) each is required
to prevent. While this is an improvement, it is hard to reason about
application semantics in terms of the undesirable phenomena. Moreover,
a later critique~\cite{berenson} uncovers many ambiguities and
shortcomings in the standard. Adya's thesis~\cite{adyaphd} includes
first formal definitions of some of the well-known isolation levels in
the context of a system model of sequentially consistent database
complete with timestamps and version histories. However, Adya's model,
which predates the proliferation of weakly consistent replicated data
stores, is not enough to express the semantics of a host of new
isolation levels~\cite{psi,nmsi} tailor-made for such stores, or the
interplay between weak consistency and isolation. Nonetheless,
regardless of the specification methodology employed, the major
missing piece in all the aforementioned approaches is the bridge
between the system model of specifications and the operational model
of programs that enables formal reasoning about program invariants in
presence of weak isolation.

There have been encouraging developments in Programming Languages
research towards addressing the problem of reasoning about application
invariants on weakly consistent replicated stores~\cite{burckhardt14,
redblueosdi, redblueatc, ecinec, gotsmanpopl16}. Weak isolation can
make use of some of the reasoning inventory built for weak consistency
(as we demonstrate in later sections), but the latter does not subsume
the former. While weak consistency (as considered by the
aforementioned research) deals with lazily propagating effects of
atomic and fully isolated operations, reasoning about weakly isolated
transactions involves reasoning about the effects of groups of
operations that are not necessarily atomic or isolated. Indeed, weakly
isolated transactions have existed on sequentially consistent
relational databases long before the advent of weakly consistent
replicated stores, indicating the subtle interplay between consistency
and isolation. Moreover, a common theme among the aforementioned line
of work is the assumption of a system with a predefined set of
consistency levels, and a minimum consistency level that is often
stronger than eventual consistency. For instance, the reasoning
framework proposed in~\cite{gotsmanpopl16} crucially relies on the
assumption of causal consistency with only admissable strengthening
being strong consistency. None of the ANSI SQL weak isolation levels
guarantee causal consistency. Moreover, there exist real-world
distributed stores~\cite{spanner} that offer serializable transactions
without causal consistency. Evidently, the reality is significantly
more diverse~\cite{zoo}, with more forms of weak consistency and
isolation being invented to meet the changing needs of applications.
What is needed in this context is a reasoning framework parameterized
over the semantics of weak isolation, that can answer the following
question:
\begin{center}
\emph{Given a program annotated with desired invaraints, and a
selection of isolation levels for transactions in the program, are the
invariants guaranteed to hold?}
\end{center}

In this paper, we propose a reasoning framework that attempts to
answer this question.

