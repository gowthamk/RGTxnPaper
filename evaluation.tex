\section{Evaluation}
\label{sec:case-studies}

In this section, we present our experience in running \thetool on two
different applications: \emph{Courseware}: a course registration
system described by~\cite{gotsmanpopl16}, and TPC-C.

\begin{figure}[t]
\begin{ocaml}
  type table_name = Student | Course | Enrollment
  type student = {s_id: id; s_name: string}
  type course = {c_id: id; c_name: string; c_capacity: int}
  type enrollment = {e_id: id; e_s_id: id; e_c_id: id}

  let enroll_txn sid cid = 
    let crse = SQL.select1 [Course] (fun c -> c.c_id = cid) in
    let s_c_enrs = SQL.select [Enrollment] (fun e -> e.e_s_id = sid && 
                                                     e.e_c_id = cid) in
    if crse.c_capacity > 0 && Set.is_empty s_c_enrs then
      (SQL.insert Enrollment {e_id=new_id (); e_s_id=sid; e_c_id=cid};
       SQL.update Course (fun c -> {c with c_capacity = c.c_capacity - 1})
                         (fun c -> c.c_id = cid)) else ()
       
  let deregister_txn sid = 
    let s_enrs = SQL.select [Enrollment] (fun e -> e.e_s_id = sid) in
    if Set.is_empty s_enrs then
      SQL.delete Student (fun s -> s.s_id = sid) else ()
\end{ocaml}
\caption{Courseware Application}
\label{fig:courseware_code}
\vspace*{-10pt}
\end{figure}

\textbf{Courseware} The Courseware application allows new courses to be
added (via an \C{add\_course} transaction), and new students to be
registered (via a \C{register} transaction) into a database. A registered
student can enroll (\C{enroll}) in an existing course,
provided that enrollment has not already exceeded the course
capacity (\C{c\_capacity}). A course with no enrollments can be
canceled (\C{cancel\_course}). Likewise, a student who is not enrolled
in any course can be deregistered (\C{deregister}). Besides
\C{Student} and \C{Course} tables, there is also an \C{Enrollment}
table to track the many-to-many enrollment relationship between
courses and students. The simplified code for the Courseware
application with only \C{enroll} and \C{deregister}
transactions is shown in Fig.~\ref{fig:courseware_code}. The
application is required to preserve the following invariants on the
database:

\begin{enumerate}
\item  $I_1$: An enrollment record should always refer to an existing student and an existing course.
\item  $I_2$: The capacity (\C{c\_capacity}) of a course should always be a
  non-negative quantity.
\end{enumerate}
\noindent Both $I_1$ and $I_2$ can be violated under weak isolation.
$I_1$ can be violated, for example, when \C{deregister} runs
concurrently with \C{enroll}, both at RC isolation. While the former
transaction removes the student record after checking that no
enrollments for that student exists, the latter transaction
concurrently adds an enrollment record after checking the student
exists.  Both can succeed concurrently, resulting in an invalid state.
Invariant $I_2$ can be violated by two \C{enroll}s, both reading
\C{c\_capacity}=1, and both (atomically) decrementing it, resulting in
\C{c\_capacity}=-1.  We ran \thetool on the Courseware application
(Fig.~\ref{fig:courseware_code}) after annotating transactions with
their respective guarantees, and asserting $I = I_1 \wedge I_2$ as the
correctness condition. The guarantees $G_e$ and $G_d$ for \C{enroll}
and \C{deregister} transactions, respectively, are shown below:
\begin{smathpar}
  \begin{array}{lcl}
    G_e(\stg,\stg') & \Leftrightarrow & \stg_s'=\stg_s
      \conj \exists\C{cid}.\exists\C{sid}.\\
    & & \hspace*{0.3in} \stg_c' = \stg_c \bind \lambda c.~
        \itel{c.\C{c\_id}=\C{cid}\\
    & & \hspace*{1.15in}}
          {\existsl(c',~c'.\C{id}=c.\C{id} \wedge
              c'.\C{c\_name}=c.\C{c\_name} \\
    & & \hspace*{2.6in}\wedge~ c'.\C{c\_capacity}\ge0, ~\{c'\})\\
    & & \hspace*{1.15in}}
          {\{c\}}\\
    & & \hspace*{0.15in}\conj \stg_e = \stg_e' \bind \lambda e.~ 
        \itel{e.\C{e\_c\_id}=\C{cid} \wedge e.\C{e\_s\_id}=\C{sid}}
          {\emptyset}{\{e\}}\\
%   & & \hspace*{1.15in}} 
%         {\emptyset} {\{e\}}\\
    G_d(\stg,\stg') & \Leftrightarrow & \stg_c' = \stg_c \conj
      \stg_e' = \stg_e \conj \exists \C{sid}.~
      \itel{\forall(e \in \stg_e).~e.\C{e\_s\_id}\neq\C{sid}\\
%   & & \hspace*{0.3in} \itel{\forall(e \in
%           \stg_e).~e.\C{e\_s\_id}\neq\C{sid}\\
    & & \hspace*{1.55in}}
          {\stg_s' = \stg_s \bind \lambda s.~
           \itel{s.\C{id}=\C{sid}}{\emptyset}{\{s\}}\\
    & & \hspace*{1.55in}}
          {\stg_s' = \stg_s}\\
  \end{array}
\end{smathpar}
For the sake of this presentation we split $\stg$ into three disjoint
sets of records, $\stg_s$, $\stg_c$, and $\stg_e$, standing for
\C{Student}, \C{Course}, and \C{Enrollment} tables, respectively.
Observing that the set language $\SL$ (Sec.~\ref{sec:inference}),
besides being useful for automatic verification, also facilitates
succinct expression of transaction semantics, we define $G_e$ and
$G_d$ in a combination of FOL and $\SL$. $G_e$ essentially says that
the \C{enroll} transaction leaves the \C{Student} table unchanged,
while it may update the \C{c\_capacity} field of a \C{Course} record
to a non-negative value (even when it doesn't update, it is the case
that $c'.\C{c\_capacity}\ge0$, because $c'=c$, and $c\in\stg_c$, and
we know that $I_2(\stg_c)$). $G_e$ also conveys that \C{enroll} might
insert a new \C{Enrollment} record by stating that $\stg_e$, the
\C{Enrollment} table in the pre-state, contains all records $e$ from
$\stg_e'$, the table in the post-state, except when $e.\C{e\_c\_id}$ and
$e.\C{e\_s\_id}$ match \C{cid} and \C{sid}, respectively. The
guarantee $G_d$ of \C{deregister} asserts that the
transaction doesn't write to \C{Course} and \C{Enrollment} tables. The
transaction might however delete a \C{Student} record bearing an
\C{id}=\C{sid} (formally, $\stg_s' = \stg_s \bind \lambda s.~
\itel{s.\C{id}=\C{sid}}{\emptyset}{\{s\}}$), for some \C{sid} for
which no corresponding \C{Enrollment} records are present in the
pre-state (in other words, $\forall(e \in
\stg_e).~e.\C{e\_s\_id}\neq\C{sid}$).

With help of the guarantees, such as those described above, \thetool
was able to automatically discover the aforementioned anomalous
executions, and was subsequently able to infer that the anomalies can
be preempted by promoting the isolation level of \C{enroll} and
\C{deregister} to SER (on both MySQL and PostgreSQL), leaving
the isolation levels of remaining transactions at RC. The total time
for inference and verification took less than a minute running on a
conventional laptop.

\begin{table}[]
\centering
\begin{tabular}{l|c|c|c|c|c|}
\cline{2-6}
                                 & \multicolumn{1}{l|}{\C{new\_order}} & \multicolumn{1}{l|}{\C{delivery}} & \multicolumn{1}{l|}{\C{payment}} & \multicolumn{1}{l|}{\C{order\_status}} & \multicolumn{1}{l|}{\C{stock\_level}} \\ \hline
\multicolumn{1}{|l|}{MySQL}      & SER                                   & SER                                 & RC                                 & RC                                       & RC                                      \\ \hline
\multicolumn{1}{|l|}{PostgreSQL} & SI                                    & SI                                  & RC                                 & RC                                       & RC                                      \\ \hline
\end{tabular}
\caption{The discovered isolation levels for TPC-C transactions}
\label{tab:tpcc}
\vspace*{-10pt}
\end{table}

\textbf{TPC-C} The simplified schema of the TPC-C benchmark has been
described in Sec.~\ref{sec:motivation}. In addition to the tables
shown in Fig.~\ref{fig:schema}, the TPC-C schema also has
\C{Warehouse} and \C{New\_order} tables that are relevant for
verification.  To verify TPC-C, we examined four of the twelve
consistency conditions specified by the standard, which we name $I_1$
to $I_4$:

\begin{enumerate}
\item Consistency condition $I_1$  requires that the sales bottom line
of each warehouse equals the sum of the sales bottom lines of all
districts served by the warehouse.

\item Conditions $I_2$ and $I_3$ effectively enforce uniqueness of ids assigned
  to \C{Order} and \C{New\_order} records, respectively, under a district.


\item  Condition $I_4$ requires that the number of order lines under a district
  must match the sum of order line counts of all orders under the district.
% There are five transactions in TPC-C, out of which two are read-only.
% The three remaining transactions are \C{new\_order}, \C{delivery}, and
  % \C{payment}.
\end{enumerate}

Similar to the example discussed in Sec.~\ref{sec:motivation}, there
are a number of ways TPC-C's transactions violate the aforementioned
invariants under weak isolation. \thetool was able to discover all such
violations when verifying the benchmark against $I =
\bigwedge_{i}I_i$, with guarantees of all three transactions
provided. The isolation levels were subsequently strengthened  as
shown in Table.~\ref{tab:tpcc}.  As before, inference and verification
took less than a minute.

%% \begin{table*}[t]\small
%% \centering
%% \begin{tabular}{|c|c|c|c|}
%%   \hline
%% \textbf{Transaction}   & \textbf{Invariant} 
%% & \textbf{MySQL-Isolation} & \textbf{PostgreSQL-Isolation} \\ 
%% \hline
%% \multirow{4}{*}{\C{New\_Order} }  & $I_1$ 
%% & RC &  RC\\ 
%% &  $I_2$ &SER & RR \\
%% &  $I_3$ & SER  &  RR  \\
%% & $I_4$ & RC & RC   \\
%% \hline
%% \multirow{4}{*}{\C{Payment}}  & $I_1 $ 
%% & RC &  RC\\ 
%% &  $I_2$  &RC & RC \\
%% &  $I_3 $ & RC  &  RC  \\
%% & $I_4$  & RC & RC   \\
%% \hline
%% \multirow{4}{*}{\C{Delivery}}  & $I_1$  
%% & RC &  RC \\ 
%% &  $I_2$ &SER & RR \\
%% &  $I_3$ & SER  &  RR \\
%% & $I_4$  & RC & RC   \\
%% \hline
%% \end{tabular}
%% \caption{Various invariant violations witnessed for the TPC-C
%%   benchmark on MySQL and PostgreSQL}
%% \label{tab:tpcc-eval}
%% \end{table*}

To sanity-check the results of \thetool, we conducted experiments with a
high-contention OLTP workload on TPC-C aiming to explore the space of
correct isolation levels for different transactions. The workload
involves a mix of all five TPC-C transactions executing against a
TPC-C database with 10 warehouses. Each warehouse has 10 districts,
and each district serves 3000 customers. There are a total of 5
transactions in TPC-C, and given that MySQL and PostgreSQL support 3
isolation levels each, there are a total of $3^5 = 243$ different
configurations of isolation levels for TPC-C transactions on MySQL and
PostgreSQL. We executed the benchmark with all 243 configurations, and
found 171 of them violated at least one of the four invariants we
considered.  As expected, the isolation levels that \thetool infers for the
TPC-C transactions do not result in invariant violations, either on
MySQL or on PostgreSQL, and were determined to be the weakest safe
assignments possible.

