\section{Data Stores and Consistency}
\label{sec:store-consistency}

The operational semantics of Fig.~\ref{fig:txnimp} allows operations
to witness arbitrary subsets of the global state, effectively mimicking the
behaviour of an eventually consistent ({\sc ec}) data
store\footnote{Eventual consistency guarantees that in the absence of further
  updates, all reads witness the same global state
  \emph{eventually}. In any finite trace, however, there are no
  guarantees on what a read may witness.}. There are, however, data stores,
such as relational databases, that provide stronger consistency
guarantees than {\sc ec}. Like the isolation levels of transactions,
the consistency level of the underlying store also affects the
semantics of a program in non-trivial ways. In this section, we
demonstrate how the semantics of stronger stores with on-demand weak
isolation can be captured in our operational model. 

% A non-trivial $\I$ composed of isolation specifications from
% Fig.~\ref{fig:ansi-isolation} induces the machine to provide
% non-trivial isolation guarantees for transactions. However, weak
% isolation levels often only constrain the visibility sets of
% operations by dictating what \emph{not} to see; not what to see.  For
% instance, \iso{Repeatable Read} isolation prohibits operations of a
% transaction from witnessing different states. It, however, does not
% prohibit all operations of a transaction from witnessing an aribitrary
% subset of the global state. Consequently, the machine can remain an
% {\sc ec} store even while providing non-trivial isolation. How then to
% model the semantics of an {\sc sc} store, such as a relational
% database, with variable (weak) isolation?

First, we observe that the semantics of a weakly-consistent data store
can be captured by store-specific consistency constraints, along with
transaction-specific isolation constraints, via the trace invariant
$\I$. In particular, we can split $\I$ into two components: (1).
$\I_s$, the store-specific invariant, and (2). $\I_c$, the
program-specific (or, client-specific) invariant, to capture
consistency and isolation constraints, resp.  $\I$ is now a
conjunction: $\I \,=\, \lambda\E.~\I_s(\E) \wedge \I_c(\E)$ (often
simplified to $\I \,=\, \I_s\wedge\I_c$).  While the program-specific
trace invariant ($\I_c$) remains an invariant regardless of the
specific consistency and visibility features exposed by the underlying
data store, the store specific invariant ($\I_s$) changes from store
to store depending on the consisteny level.  For an eventually
consistent store, $\I_s$ is simply \emph{true}. Stronger stores, such
as those that support strong consistenty, have non-trivial definitions
for $\I_s$.

A strongly-consistent {\sc sc} store guarantees a total order on all
operations w.r.t $\visZ$ consistent with their chronological order. A
straightforward $\I_s$ for this store is the \C{SC} property
formalized below:
\begin{smathpar}
\begin{array}{l}
  \C{sc}(\E) \;=\; \forall\eta_1,\eta_2.~\{\eta_1,\eta_2\}
  \subseteq \E.\A \conj \id(\eta_1) < \id(\eta_2) \\
  \hspace*{2in}\Rightarrow \underE{\eta_1 \visar \eta_2}
\end{array}
\end{smathpar}
Unfortunately, $\I_s=\C{SC}$ conflicts with all isolation
specifications of Fig.~\ref{fig:ansi-isolation}. For instance,
consider a case where $\I_c(\E) \;=\; \forall
T_i.~\underE{\C{RC}(T_i)}$, a constraint that dictates all
transactions execute under \iso{Read Committed} isolation. Imagine a
sample execution where $\eta_1$'s transaction is not yet committed
when $\eta_2$ is generated. Letting $\eta_1$ be visible to $\eta_2$
violates $\I_c$, whereas not letting it be visible violates $\I_{s}$.
The only way to satisfy both invariants is to rule out all 
executions that interleave the operations of one transaction with the
other, thereby enforcing serializability.  In general, when $\I_s$ conflicts (but is not
inconsistent) with $\I_c$, the only way to enforce both invariant sets
is to restrict concurrency. Clearly, this is unacceptable since it
defeats the very purpose of supporting weak isolation. 
% How then do we enforce weak isolation on a strongly consistent
% machine?

In practice, relational databases resolve such conflicts by
prioritizing weak isolation (thus, concurrency and performance) over
strong consistency, so the execution traces do not necessarily satisfy
{\sc sc}. In particular, visibility constraints imposed by {\sc sc}
are violated iff they are found to be in conflict with the constraints
imposed by a transaction's isolation level. In the context of
the aforementioned example, $\eta_1$ is not made visible to $\eta_2$
because doing so would violate $\I_c$. However, if $\I_c$ is true,
then the store makes $\eta_1$ visible to $\eta_2$ to honor its
consistency commitment\footnote{The term \emph{recency
    commitment}~\cite{bailishat} is often used in practice
  to capture the best-effort nature of {\sc sc}.}. We generalize this
approach to any $\I_s$ and $\I_c$ by defining a \emph{maximum
  visiblity principle} to determine an acceptable weakening of $\I_s$
in case of a conflict with $\I_c$.  The principle requires the
weakened consistency guarantee ($\I_s'$) of the store to enforce all
visibility relationships imposed by the actual consistency guarantee
($\I_s$), unless enforcing such a relationship violates $\I_c$.
% The formal definition of the principle is relegated
% to the supplementary in the interest of space, but it can be
% understood in the context of an {\sc sc} store, where it weakens the
% store invariant to the following:
Formally:
\begin{definition}
$\I_s' : \E \rightarrow \Prop$ is said to be a maximum visibility
weakening of $\I_s : \E \rightarrow \Prop$ if and only if:
\begin{itemize}
  \item $\I_s'$ is weaker than $\I_s$: 
      $\forall\E.~ \I_s(\E) \Rightarrow \I_s'(\E)$, and
  \item In every trace $\E$ that satisfies $\I_c$, and for every pair
  of effects $\eta_1$ and $\eta_2$ in $\E$, if $\I_s(\E)$ requires
  $\eta_1$ to be visible to $\eta_2$, then so does $\I_s'(\E)$ unless
  extending $\E$ with $\visZ(\eta_1,\eta_2)$ violates
  $\I_c$\footnote{\GK{ToDo: consider other well-formedness conditions
  on trace, such as acyclicity of $\visZ$ and $\soZ$. Are they needed
  (considering that the machine never violates them)? Encode the
  specifications in Z3 and make sure they are consistent.}}:
  \begin{smathpar}
  \begin{array}{l}
  \forall\E,\eta_1,\eta_2.~ \I_c(\E) \Rightarrow (\I_s(\E)
    \Rightarrow \underE{\eta_1 \visar \eta_2}) \Rightarrow \\
    \hspace*{0.5in}(\I_s'(\E) \Rightarrow \underE{\eta_1 \visar
    \eta_2} \disj \neg\I_c(\E\,\cup\,(\emptyset,\{(\eta_1,\eta_2)\})))
  \end{array}
  \end{smathpar}
\end{itemize}
\end{definition}
Applying this principle, we can weaken {\sc sc} to obtain the
following store trace invariant ($\I_s$) for an {\sc sc} store whose
isolation constraints are captured by $\I_c$:
\begin{smathpar}
\begin{array}{lcl}
\I_s(\E) & = & \forall \eta_1,\eta_2.\, \{\eta_1,\eta_2\},
    \subseteq \E.\A \conj \id(\eta_1) <
    \id(\eta_2) \\
    & & \hspace*{0.5in} \Rightarrow 
      \underE{\eta_1 \visar \eta_2} \disj \neg\I_c(\E
    \cup (\emptyset,\{(\eta_1,\eta_2)\}))\\
\end{array}
\end{smathpar}
$\I_s$ requires a trace $\E$ to satisfy the visibility constraints of
    {\sc sc} except in cases where they are in conflict with $\I_c$.
    Instantiating the parameter $\I$ with $\I_s \wedge \I_c$ in
    Fig.~\ref{fig:txnimp} results in an operational semantics that
    describes many kinds of relational database-like data stores,
    including causally-consistent data stores, among
    others.\footnote{Details of this instantiation are relegated to
      the supplementary in the interest of space.}

%% \begin{remark}
%% Note that the purpose of maximum visibility principle is to
%% rationalize the observed behaviour of databases in practice. In
%% particular, it is not intended to be a guiding principle to engineer
%% data stores.
%% \end{remark}

% \paragraph{A CC store} A causally consistent data store~\cite{gotsmanpopl16,LBC16}
% allows operations to only witness a causally consistent snapshot of the
% global state. The store-specific invariant obtained by weakening the
% {\sc cc} guarantee to account for conflicts with $\I_c$ is shown
% below (the original {\sc cc} does not contain the $\neg\I_c(\dots)$
% disjuncts): 
% \begin{smathpar}
% \begin{array}{lccl}
% \C{CC}(\E) & \;=\; &  & \forall \eta_1,\eta_2.\, 
%       \E \Vdash \eta_1 \soar \eta_2 \Rightarrow  \underE{\eta_1 \visar
%       \eta_2} \\
%     & & & \hspace*{0.6in}\disj \neg\I_c(\E \cup 
%                 (\emptyset,\{(\eta_1,\eta_2)\}))\\
%     &   & \wedge & \forall\eta_1,\eta_2,\eta_3.\,\underE{\eta_1 \visar
%       \eta_2} \conj \underE{\eta_2 \visoar \eta_3} \\
%     &   & &\hspace*{0.3in} \Rightarrow \underE{\eta_1 \visar \eta_3}
%       \disj \neg\I_c(\E \cup (\emptyset,\{(\eta_1,\eta_2)\}))\\
% \end{array}
% \end{smathpar}

% \noindent Instantiating the parameter $\I$  with $\I_s \wedge \I_c$ in
% Fig.~\ref{fig:txnimp} results in an operational semantics that admits
% violation of causal consistency if and only if the violation is
% inevitable to enforce $\I_c$.

\subsection{Weakly Consistent Replication}
\label{sec:replication}

\begin{figure}
\centering
\subcaptionbox {
  Replica model
  \label{fig:ec-theirs}
} [
  0.4\columnwidth
] {
  \includegraphics[scale=0.7]{Figures/ec-theirs}
 
}
\hspace*{0.1in}
\subcaptionbox {
  Subset model
  \label{fig:ec-ours}
}{
  \includegraphics[scale=0.45]{Figures/ec-ours}
} \caption{In the replica model, operation $\op$ generates effect
$\eta$ at replica $R_1$, which is then merged to $R_2$. If the
\emph{store is {\sc cc}}, then $R_2$'s state at merge event is same or
larger than $R_1$'s state at generation event (the difference is
highlighted). In our subset model, $\op$ witnesses $S_1 \subseteq
\E.\A$ and generates $\eta$, which is immediately added to $\E.\A$. A
later operation may witness $S_2 \subseteq \E.\A$, and if the
\emph{operation is} {\sc cc} and $\eta \in S_2$, then it also
witnesses $S_1$ (i.e., $S_1 \subseteq S_2$). } 
% Moreover, Like $R_2 - R_1$, if all effects in $S_2 - S_1$ are
% concurrent with $\eta$, i.e., $\not\exists\eta'.~\eta' \in S_2 - S_1
% \conj % visZ(\eta,\eta')$, then any precondition $P$ that is valid
% when $\op$ executed is also valid when $\eta$ is witnessed because
% of the stability condition.
\label{fig:ec-theirs-vs-ours}
\end{figure}

Reasoning under weakly-consistent replication has received special
attention in recent work~\cite{gotsmanpopl16}. Our operational
semantics and proof system are general enough to admit replication as
a special case of our formulation. In this section, we explain how the
standard artifacts of weakly-consistent replication manifest in our
reasoning framework.

The primary challenge in this setting is to ensure that the
assumptions made and guarantees enforced by an operation at one
replica carry over to other replicas that merge their effects, thus
preserving the overall integrity of the system.  In prior
work~\cite{lbc16,gotsmanpopl16}, this challenge is partly addressed by
imposing restrictions on how various replica states differ, i.e., by
fixing a system model with a stronger baseline consistency ({\sc cc})
than {\sc ec}. This unfortunately restricts the reasoning approach
from being applied to data stores (e.g., \cite{bayou,pldi15}) that provide
guarantees weaker than causal consistency, such as causal visibility
or read-my-writes~\cite{zoo}. Causal consistency is not baseline
consistency in these stores because it is not \emph{highly
  available}~\cite{bailishat}.

Notably, our view of replication does not explicitly involve replicas.
Fig.~\ref{fig:ec-theirs-vs-ours} contrasts our model of
weakly-consistent replication with a conventional replica-based model.
Under our model, the notion of a replica is subsumed by the concept of
visibility; a replica is defined by the subset ($S$) of global state
($\E.\A$) that an operation witnesses. Constraints over replica states
therefore manifest as constraints over a specific visibility relation.
For example, instead of requiring the store to be causally consistent,
an operation can witness a causally consistent subset of the state;
such demands can be made via the trace invariant $\I$. For a
precondition ($P$) of the operation to be useful, it has to be an
assertion over every causally consistent subset of the global state.
Since any replica that eventually executes the operation has to expose
one such subset ($S$), the precondition is guaranteed to hold
regardless of the replica. There is however one problem with this
explanation - by considering subsets of just one global state, it
ignores the fact that the global state (hence, the replica states)
change during the execution of the operation. To account for such
changes, we might choose to distinguish between effect generation
event at one replica $r_1$ and effect merge event at replica $r_2$,
requiring that \emph{non-conflicting} operations execute between these
two events at $r_2$, and that they preserve certain
invariants~\cite{gotsmanpopl16}.  Instead, our framework folds all such
machinery into a stability condition predicated on $\I$
(\S\ref{sec:rely-guarantee}).  Since any change to the global state
during the execution of the operation is an interference, and $P$ is
required to be stable with respect to any such interference, it
follows that $P$ is valid on every replica, thus ensuring that
assumptions made at a generation event is also valid at the merge
event.

\subsection{Example}

We shall now consider the proof of the example in
Fig.~\ref{fig:motiv-eg-1} in greater detail. We assume an {\sc sc}
store, such as a relational database, whose store-specific trace
invaraint ($\I_s$) was shown previously. Both transactions are run at
{\sc si} isolation, hence $\I_c$ is $\lambda\E.~\underE{\C{SI(Wd1)}}
\conj \underE{\C{SI(Wd1)}}$. As usual, $\I$ is $\I_s \conj \I_c$. 

\begin{figure}
\centering
\begin{txnimpcode}
 $\begin{decoration}
 P_1:\{ {\neg\committed(\C{Wd2})} \Rightarrow \C{C = k} \conj\\
        \hspace*{0.3in}{\committed(\C{Wd2})} \Rightarrow \C{Wd2}
        \visar \C{Wd1} \wedge \C{Wd2} \wrstoar \C{C} \wedge \C{C = k-a2} \}
 \end{decoration}$
  txn$\langle$'Wd1'$\rangle${
   $\begin{decoration}
    \phi_1 : \{{\neg\committed(\C{Wd2})} \Rightarrow \C{C = k} \conj
      {\committed(\C{Wd2})} \Rightarrow \C{Wd2} \wrstoar \C{C} \conj\\
       \hspace*{0.3in}{\committed(\C{Wd2})} \wedge
        {\C{Wd2} \visar \C{Wd1}} 
       \Rightarrow \C{C = k-a2} \}
    \end{decoration}$ 
    v1 = C
   $\begin{decoration}
    \phi_2 : \{{\neg\committed(\C{Wd2})} \Rightarrow \C{C = k} \wedge \C{v1 = k} \conj\\
       \hspace*{0.3in}{\committed(\C{Wd2})} \Rightarrow \C{Wd2} \wrstoar \C{C} \conj \\
       \hspace*{0.3in}{\committed(\C{Wd2})} \wedge
        {\C{Wd2} \visar \C{Wd1}} 
       \Rightarrow \C{C = k-a2} \wedge \C{v1 = k-a2}\}
    \end{decoration}$ 
    if (v1 $\ge$ a1) {
      v2 = C;
     $\begin{decoration}
      \phi_3 : \{{\neg\committed(\C{Wd2})} \Rightarrow \C{C = k} \wedge \C{v2 = k} \conj\\
       \hspace*{0.3in}{\committed(\C{Wd2})} \Rightarrow \C{Wd2} \wrstoar \C{C} \conj \\
         \hspace*{0.3in}{\committed(\C{Wd2})} \wedge
          {\C{Wd2} \visar \C{Wd1}} \Rightarrow \C{C = k-a2} \wedge \\
          \hspace*{1.9in}\C{v2 = k-a2}\}
      \end{decoration}$ 
      v3 = v2 - a1;
     $\begin{decoration}
      \phi_4 : \{{\neg\committed(\C{Wd2})} \Rightarrow \C{C = k} \wedge \C{v3 = k-a1} \conj\\
         \hspace*{0.3in}{\committed(\C{Wd2})} \Rightarrow \C{Wd2} \wrstoar \C{C} \conj \\
         \hspace*{0.3in}{\committed(\C{Wd2})} \wedge
          {\C{Wd2} \visar \C{Wd1}} 
         \Rightarrow \C{C = k-a2} \wedge \\
         \hspace*{1.9in}\C{v3 = k-a2-a1}\}
      \end{decoration}$ 
      C := v3
     $\begin{decoration}
      \phi_5 : \{{\neg\committed(\C{Wd2})} \Rightarrow \C{C = k-a1}) 
                \conj\\
         \hspace*{0.3in}{\committed(\C{Wd2})} 
                \Rightarrow \C{C = k-a1-a2}\}
      \end{decoration}$ 
    }
  }
 $\begin{decoration}
  Q_1 : \{{\neg\committed(\C{Wd2})} \Rightarrow \C{C = k-a1}
            \conj \committed(\C{Wd1}) \conj\\
      \hspace*{0.12in}{\committed(\C{Wd2})} 
          \Rightarrow \C{C = k-a1-a2} \}
  \end{decoration}$ 
\end{txnimpcode}

\caption{\C{Wd1} transaction decorated with assertions}
\label{fig:wd1-decorated}
\end{figure}

The fully decorated implementation of transaction \C{Wd1} is shown in
Fig.~\ref{fig:wd1-decorated}. Decorated \C{Wd2} is similar and not
shown. Assignment statements are broken down and temporary local
variables (\C{v1}, \C{v2} and \C{v3}) are introduced so as to separate
shared variable reads and writes. All assertions implicitly refer to
the current execution ($\E$), just as hoare triples implicitly refer
to the current state. The context for propositions is also the
implicit, i.e., we write $\psi$ instead of $\underE{\psi}$. The
proposition \C{k $\ge$ a1+a2} remains an invariant, hence elided. The
precondition ($P_1$) of \C{Wd1} accounts for the possibility of
\C{Wd2} committing before \C{Wd1}, writing \C{k-a2} to \C{C}.
Precondition of \C{Wd2} is similar.  Since neither \C{Wd1} nor \C{Wd2}
are committed at the beginning, the execution-based assertion
corresponding to the precondition ($P$) of Fig.~\ref{fig:motiv-eg-1}
must include $\neg\committed(\C{Wd1}) \wedge \neg\committed(\C{Wd2})$,
from which $P_1$ follows. Once the execution is inside \C{Wd1}, commit
of \C{Wd2} ($\committed(\C{Wd2})$) may mean that either \C{Wd2}
happened before \C{Wd1} (hence can be visible to all of \C{Wd1}), or
that it committed concurrently with \C{Wd1} (hence cannot be visible
to all of \C{Wd2}).  Since SI proscribes the latter possibility, we
only consider the case when $\C{Wd2} \visar \C{Wd1}$. A proof for
$\C{Wd2} \visar \C{Wd1}$ is obtained subsequently, allowing us to get
rid of the special case.

First, we focus on the sequential aspect of the proof and show that
the assertions that decorate \C{Wd1} are indeed valid. The proof for
each triple follows from the rule for the corresponding term in
Fig.~\ref{fig:rg-rules}. For illustration, we consider the triple
corresponding to the assignment statement (line ??). The precondition
($\phi_4$) asserts that \C{Wd2} writes to \C{C}, and the value of the
temporary variable \C{v3} is \C{k-a2-a1}. The RG rule
(\rulelabel{RG-Asgn}) for assignment statement allows us to easiliy
conclude the following about the execution state after the assignment:

\begin{smathpar}
\begin{array}{l}
    {\neg\committed(\C{Wd1}) \conj \C{Wd1} \wrstoar \C{C} 
    \conj (\neg\committed(\C{Wd2})} \Rightarrow \C{C = k}) \conj\\
    ({\committed(\C{Wd2})} \Rightarrow \C{Wd2} \wrstoar
    \C{C}) \conj \\
    ({\committed(\C{Wd2})} \wedge {\C{Wd2} \visar \C{Wd1}} 
    \Rightarrow \C{C = k-a2} \wedge \C{C = k-a2-a1})
\end{array}
\end{smathpar}

\noindent The rule also lets us assume that the execution satisfies trace
invariant ($\I$), which asserts {\sc si} for both transactions.  Since
both transactions write to \C{C}, {\sc si} requires either $\C{Wd1}
\visar \C{Wd2}$, or $\C{Wd2} \visar \C{Wd1}$. Since \C{Wd1} is not yet
committed ($\neg\committed(\C{Wd1})$), {\sc si} prohibits the former
possibility, allowing us the deduce the $\C{Wd2} \visar \C{Wd1}$. This
lets us derive ${\committed(\C{Wd2})}  \Rightarrow \C{C = k-a2} \wedge
\C{C = k-a2-a1}$, allowing us to prove the postcondition ($\phi_5$).

The second part of the proof is to show that assertions are stable
despite the interference from the the concurrent thread executing
\C{Wd2}. The interference is given by the following rely relation
($R_1$):

\begin{smathpar}
\begin{array}{lcl}
  R_1 & = & \{ (\E,\E') \;|\; \neg\underE{\committed(\C{Wd2})} \conj 
        \underE{\I} \conj \E'\Vdash \I \conj\\
%       \conj (\E'-\E) \subseteq \C{Wd2} \conj \\
%   & & \hspace*{0.5in} \E' \Vdash \committed(\C{Wd2}) ~\Rightarrow~ \E'
%       \Vdash \C{Wd2} \wrstoar \C{C} \conj \\ 
%   & & \hspace*{0.5in} \underE{\committed(\C{Wd1})} \conj \E' \Vdash
%   \committed(\C{Wd2}) \Rightarrow \C{C=k-a1-a2} \\
    & & \hspace*{0.5in} \neg\underE{\committed(\C{Wd1})} \conj
        \C{COMMIT(Wd2)} \in (\E'-\E) \\
    & & \hspace*{0.8in}\Rightarrow \C{C=k-a2} \conj 
        \E' \Vdash \C{Wd2} \wrstoar \C{C} \conj \\
    & & \hspace*{0.5in} \underE{\committed(\C{Wd1})} \conj
        \C{COMMIT(Wd2)} \in (\E'-\E) \\
    & & \hspace*{0.6in}\Rightarrow \C{C=k-a1-a2} \conj
        \E' \Vdash \C{Wd2} \wrstoar \C{C} \}\\
\end{array}
\end{smathpar}

\noindent The rely relation says the following about the concurrent thread: (1).
It may interfere only if \C{Wd2} is not already committed, (2). Any
interference takes well-formed executions to well-formed executions,
(3). If the interference commits \C{Wd2}, then \C{Wd2} should have already
written to \C{C}, and (4). The value written is either $\C{k-a1-a2}$
or $\C{k-a1}$ depending on whether or not \C{Wd1} has already committed.
Stability for most assertions is straightforward. The only non-trivial
proof is for $\phi_5$, where {\sc si} condition should be used to
show that any interference from \C{Wd2} is invalid. The proof proceeds
on the same lines as the Hoare proof discussed above; it is also
discussed in \S\ref{sec:motivation}.

The final aspect of the proof is to show that any interference from
\C{Wd1} is contained in its guarantee relation $G_1$, which becomes
the rely relation ($R_2$) for \C{Wd2}. $R_2$ (hence $G_1$) is same as
$R_1$ shown above, but with \C{Wd2} and \C{Wd1} interchanged. $\ldots$

