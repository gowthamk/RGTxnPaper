\begin{theorem}
\label{thm:inference-sound-strong}
  \emph{Forall} i,s,$\R$,$I$,$c$,$\F$, if $\stable(\R,I)$ and $c \elabsto \F$,
  then:\\\vspace*{-0.2cm}
  \begin{smathpar}
  \begin{array}{c}
  \R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{c}{\lambda(\stl,\stg).\stl = s \cup \F(s,\stg)}
  \end{array}
  \end{smathpar}
\end{theorem}
\begin{proof}
Hypothesis:
\begin{smathpar}
\begin{array}{lr}
  \stable(\R,I) & H1\\
  c \elabsto \F & H2\\
\end{array}
\end{smathpar}
Proof by induction on $H2$. 

We prove the statement separately for every type of $c$. The base cases correspond to the SQL statements INSERT, UPDATE and DELETE. 

\textbf{Case : INSERT}. We have to show that $\forall \R,I$ if $\stable(\R, I)$ and $INSERT\ x \elabsto \stabilize{\F}$, then
$$
\R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{INSERT\ x}{\lambda(\stl,\stg).\stl = s \cup \stabilize{\F}(s,\stg)}
$$
We will prove the premises of the \rulelabel{RG-Insert} rule. Here, $P \Leftrightarrow \lambda(\stl, \stg).~ \stl=s \conj I(\stg)$. By $\stable(\R, I)$, we have $\stable(\R, P)$. Note that $\stable(\R, F)$ and hence, $\stabilize{\F} = \F$. 
$Q \Leftrightarrow \lambda(\stl, \stg). \stl = s \cup F(s, \stg)$. Given $\stl, \stg, i$ such that $P(\stl, \stg)$ and $\stl' = \stl \cup \{x \with \delf=\mathit{false};\, \txnf = i\}$, it follows from definition of $F$ that $Q(\stl', \stg)$. Thus, all premises of \rulelabel{RG-Insert} are satisfied.

\textbf{Case : UPDATE}. We have to show that $\forall \R,I$ if $\stable(\R, I)$ and $UPDATE\ \lambda x.e_1\ \lambda x.e_2 \elabsto \stabilize{\F}$, then
$$
\R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{UPDATE\ \lambda x.e_1\ \lambda x.e_2}{\lambda(\stl,\stg).\stl = s \cup \stabilize{\F}(s,\stg)}
$$
We will prove the premises of the \rulelabel{RG-Update} rule. Here, $P \Leftrightarrow \lambda(\stl, \stg).~ \stl=s \conj I(\stg)$ and $Q \Leftrightarrow \lambda(\stl, \stg).~ \stl = s \cup \stabilize{\F}(\stl, \stg)$. By $\stable(\R, I)$, we have $\stable(\R, P)$. We can have either $\stable(\R, F)$ or $\neg \stable(\R, F)$. In either case, we will show that all premises of \rulelabel{RG-Update} are satisfied.

Suppose $\stable(\R, F)$. Then $\stabilize{\F} = \F$. Then, given $\stl, \stg$ such that $P(\stl, \stg)$ and $\stl' = \stl \cup \{r' \,|\, \exists(r\in\Delta).~ [r/x]e_2 =\C{true} \conj r'=[r/x]e_1 \with \idf=r.\idf;\,\delf = y.\delf;\,\txnf=i\}$, it follows from definition of $F$ that $Q(\stl', \stg)$. Suppose $\neg \stable(\R, F)$. Then, $\stabilize{\F} = \lambda(\stl, \stg).\existsl(\stg',I(\stg'),\F(\stl,\stg'))$. Also, since $P(\stl, \stg)$, we have $I(\stg)$. Hence, $Q(\stl', \stg)$, since $\stg$ provides the existential $\stg'$, and $s \cup F(s, \stg)$ is $\stl'$.  

\textbf{Case: DELETE}. We have to show that $\forall \R,I$ if $\stable(\R, I)$ and $DELETE\ \lambda x.e \elabsto \stabilize{\F}$, then
$$
\R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{DELETE\ \lambda x.e}{\lambda(\stl,\stg).\stl = s \cup \stabilize{\F}(s,\stg)}
$$
We will prove the premises of the \rulelabel{RG-Delete} rule. Here, $P \Leftrightarrow \lambda(\stl, \stg).~ \stl=s \conj I(\stg)$ and $Q \Leftrightarrow \lambda(\stl, \stg).~ \stl = s \cup \stabilize{\F}(\stl, \stg)$. By $\stable(\R, I)$, we have $\stable(\R, P)$. We can have either $\stable(\R, F)$ or $\neg \stable(\R, F)$. In either case, we will show that all premises of \rulelabel{RG-Delete} are satisfied.

Suppose $\stable(\R, F)$. Then $\stabilize{\F} = \F$. Then, given $\stl, \stg$ such that $P(\stl, \stg)$ and $\stl' = \stl \cup \{r' \,|\, \exists(r\in\Delta).~ [r/x]e=\C{true} \conj r'=\{\bar{f}=r.\bar{f}; \idf=r.\idf;\delf=\C{true}\}\}$, it follows from definition of $F$ that $Q(\stl', \stg)$. Suppose $\neg \stable(\R, F)$. Then, $\stabilize{\F} = \lambda(\stl, \stg).\existsl(\stg',I(\stg'),\F(\stl,\stg'))$.Also, since $P(\stl, \stg)$, we have $I(\stg)$. Hence, $Q(\stl', \stg)$, since $\stg$ provides the existential $\stg'$, and $s \cup F(s, \stg)$ is $\stl'$.

\textbf{Case: SELECT}. Given $\R, I$ such that $\stable(\R, I)$, $c \elabsto \F$, $G = \lambda r.~ \itel{[r/x]e}{\{r\}}{\emptyset}$, and $H =\lambda (\stl,\stg).~ [(\stg \bind G)/y]\,\F(\stl,\stg)$, we have to show that  
 $$
\R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{\lete{y}{\selecte{\lambda x.e}}{c}}{\lambda(\stl,\stg).\stl = s \cup \stabilize{H}(s,\stg)}
$$

We will prove all the premises of \rulelabel{RG-Select}. Here, $P \Leftrightarrow \lambda(\stl,\stg).~\stl=s \conj I(\stg)$, while $Q \Leftrightarrow \lambda(\stl,\stg).\stl = s \cup \stabilize{H}(s,\stg)$. By $\stable(\R, I)$, we have $\stable(\R, P)$. By inductive hypothesis and $c \elabsto \F$ we have
$$
\R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{c}{\lambda(\stl,\stg).\stl = s \cup F(s,\stg)}
$$
Let 
$$
P'(\stl, \stg) \Leftrightarrow P(\stl, \stg) \wedge y=\{r | \exists (r \in \stg) [r/x]e\}
$$

Given $\stl, \stg$, $P'$ just binds $y$ to a set of records which depend on $\stg$. We now have the following from the inductive hypothesis:
$$
\R \vdash \hoare {P'} {c} {\lambda(\stl, \stg). \stl = s \cup \stabilize{[(\stg \bind G)/y]F(\stl, \stg)}}
$$

The reason is that $y$ occurs free in $c$ and by the inductive hypothesis, any binding of $y$ can be used. Note that if $P'(\stl, \stg)$, then $y=(\stg \bind G)$. If $\stable(\R, \lambda(\stl, \stg).[(\stg \bind G)/y]F(\stl, \stg))$, then given $P'(s, \stg_{1})$, 
$$
\lambda(\stl, \stg).[(\stg \bind G)/y]F(s, \stg) = [(\stg_1 \bind G)/y]F(s, \stg_1)
$$ 
If $\neg \stable(\R, \lambda(\stl, \stg).[(\stg \bind G)/y]F(\stl, \stg))$, then 
$$\stabilize{\lambda(\stl, \stg).[(\stg \bind G)/y]F(\stl, \stg)} = \lambda(\stl, \stg).\existsl(\stg', I, [(\stg' \bind G)/y]F(\stl, \stg'))
$$ 
Then, given $P'(s, \stg_1)$, $I(\stg_1)$ and hence $\stg_1$ gives the existential $\stg'$. %then Due to the stabilization operator, we can always bind $y$ to the selected records which satisfy the condition $e$ in the starting global database state. 

\textbf{Case : IF-THEN-ELSE}. Given $\R, I$ such that $\stable(\R, I)$, $c_1 \elabsto \F_1$, $c_2 \elabsto \F_2$ , we have to show that  
 $$
\R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{\ite{e}{c_1}{c_2}}{\lambda(\stl,\stg).\stl = s \cup (\itel{e}{\F_1(s,\stg)}{\F_2(s,\stg)})}
$$

We will prove all the premises of \rulelabel{RG-If}. Here, $P \Leftrightarrow \lambda(\stl,\stg).~\stl=s \conj I(\stg)$, while $Q \Leftrightarrow \lambda(\stl,\stg).\stl = s \cup (\itel{e}{\F_1(s,\stg)}{\F_2(s,\stg)})$. By the inductive hypothesis and $c_1 \elabsto \F_1$, we know that
$$
\R \vdash \hoare{\lambda(\stl, \stg).~\stl=s \conj I(\stg)}{c_1}{\lambda(\stl, \stg). \stl = s \cup \F_1(s, \stg)}
$$

The post-condition in the above statement can also be written as $Q \wedge e$. Since $e$ does not access the global or local database, the above statement can be written as $\R \vdash \hoare{P \wedge e}{c_1}{Q \wedge e}$. Similarly, $\R \vdash \hoare{P \wedge \neg e} {c_2} {Q \wedge \neg e}$. By $\stable(\R, I)$, we have $\stable(\R, P)$. Thus, all the premises of \rulelabel{RG-If} are satisfied.

\textbf{Case : SEQ}. Given $\R, I$ such that $\stable(\R, I)$, $c_1 \elabsto \F_1$, $c_2 \elabsto \F_2$ , we have to show that  
 $$
\R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{c_1;c_2}{\lambda(\stl,\stg).\stl = s \cup F_1(s, \stg) \cup F_2(s \cup F_1(s, \stg), \stg)}
$$

We will prove all the premises of \rulelabel{RG-Seq}. Here, $P \Leftrightarrow \lambda(\stl,\stg).~\stl=s \conj I(\stg)$, while $Q \Leftrightarrow \lambda(\stl,\stg).\stl = s \cup F_1(s, \stg) \cup F_2(s \cup F_1(s, \stg), \stg)$. Let $Q' \Leftrightarrow \lambda(\stl, \stg). \stl = s \cup F_1(s, \stg)$. Then, by the inductive hypothesis and $c_1 \elabsto \F_1$, we have $\R \vdash \hoare{P}{c1}{Q'}$. Further, by the inductive hypothesis and $c_2 \elabsto \F_2$, we have $\R \vdash \hoare{Q'}{c_2}{Q}$. Finally, since the stabilization operator ($\stabilize{}$) is always applied on $F_1$, we have $\stable(\R, Q')$. Thus, all premises of \rulelabel{RG-Seq} are satisfied.

\textbf{Case : FOREACH}. Given $\R, I$ such that $\stable(\R, I)$, $c \elabsto \F$, we have to show that
$$
\R \vdash \hoare{\lambda(\stl,\stg).~\stl=s \conj
  I(\stg)}{\foreache{x}{\lambda y.\lambda z.~c}}{\lambda(\stl,\stg).\stl = s \cup x\bind(\lambda z.~\F(s,\stg)}
$$

We will prove all the premises of \rulelabel{RG-ForEach} using the loop invariant $\psi(\stl, \stg) \Leftrightarrow \stl = s \cup y \bind (\lambda z.~\F(s, \stg))$. Here $P \Leftrightarrow \lambda(\stl,\stg).~\stl=s \conj I(\stg)$, while $Q \Leftrightarrow \lambda(\stl,\stg).\stl = s \cup x\bind(\lambda z.~\F(s,\stg)$. Since $[\phi/y]\psi(\stl, \stg) \Leftrightarrow \stl = s$, $P \rightarrow [\phi/y]\psi$. By the inductive hypothesis and $c \elabsto \F$, we have
$$
\R \vdash \hoare{\lambda(\stl, \stg).~ \stl = s \cup y \bind (\lambda z.~\F(s, \stg)) \conj I(\stg)} {c} {\lambda(\stl, \stg). \stl = s \cup y \bind (\lambda z.~\F(s, \stg)) \cup F(s \cup y \bind (\lambda z.~\F(s, \stg)), \stg)}
$$

Now, since all iterations are independent of each other, $F(s \cup y \bind (\lambda z.~\F(s, \stg)), \stg) = F(s, \stg)$. Binding $z$ (which is free in $c$) to a record in $x$ (i.e. $z \in x$) in the pre-condition, the post condition in the above statement implies $\stl = s \cup (y \cup \{z\}) \bind (\lambda z.~\F(s, \stg))$, which is nothing but $[y \cup \{z\}/y]\psi(\stl, \stg)$. Hence, $\psi$ is a loop invariant. Finally, $[x/y]\psi \rightarrow Q$. 

From $\stable(\R, I)$, we have $\stable(\R, P)$. Since $F$ has been stabilized using the $\stabilize{}$ function, and $\psi$ is an assertion on the union of multiple applications of $F$, it follows that $\stable(\R, \psi)$. Using the same reasoning, $\stable(\R, Q)$. Thus, all the premises of \rulelabel{RG-Foreach} are satisfied.


The cases for SQL statements follow fro
the corresponding RG rules trivially. \C{LET}, \C{IF-THEN-ELSE}, and
sequence case proof follows from the inductive hypothesis. The only
interesting case is \C{FOREACH}, where the corresponding RG rule
requires a loop invariant ($\psi$). The loop invariant is as
following: $\psi(\stl,\stg) \Leftrightarrow \stl = y\bind(\lambda
z.~\F_c(\stl,\stg)$, where $\F_c$ is the transformer of the loop body.
% \begin{itemize}
%   \item \C{INSERT}: $\F$ is:
%   \begin{smathpar}
%   \begin{array}{c}
%     \stabilize{\lambda(\stl,\stg).~
%     \{ y \,|\, y = \{x \with r.\delf=\mathit{false};\, \txnf = i\} \}}
%   \end{array}
%   \end{smathpar}
%   If $\F$ is stable, we need to show the following:
%   \begin{smathpar}
%   \begin{array}{c}
%     \R \vdash \hoare{\lambda(\stl,\stg).~\stl=\emptyset \conj
%       I(\stg)}{\inserte{x}} {\lambda(\stl,\stg).\stl \subseteq \{ y
%       \,|\, y = \{x \with r.\delf=\mathit{false};\, \txnf = i\}}
%   \end{array}
%   \end{smathpar}
%   Which directly follows from the the RG rule for Insert. Since
%   $\C{INSERT}$ doesn't read $\stg$, the proof is the same even when
%   $\F$ is unstable.

%   \item \C{UPDATE}: $\F$ is:
%   \begin{smathpar}
%   \begin{array}{c}
%     \stabilize{\lambda(\stl,\stg).~ \stg \bind G }
%   \end{array}
%   \end{smathpar}
%   Where $G$ is $\lambda y.~ \itel{[y/x]e_2}
%   {\{[y/x]e_1 \with \idf=r.\idf;\,\delf = y.\delf;\,\txnf=i \}}
%   {\emptyset}$.
%   When 
% \end{itemize}
\end{proof}

\begin{theorem}
\label{thm:inference-sound}
  \emph{Forall} i,$R$,$I$,$c$,$\F$, if $\stable(\R,I)$ and $c \elabsto \F$,
  then:\\\vspace*{-0.2cm}
  \begin{smathpar}
  \begin{array}{c}
  \R \vdash \hoare{\lambda(\stl,\stg).~\stl=\emptyset \conj
  I(\stg)}{c}{\lambda(\stl,\stg).\stl = \F(\emptyset,\stg)}
  \end{array}
  \end{smathpar}
\end{theorem}
\begin{proof}
  Follows from the stronger version of this theorem
  (Theorem~\ref{thm:inference-sound-strong}) by substituting
  $\emptyset$ for $s$.
\end{proof}
