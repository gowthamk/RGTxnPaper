\section{The Reasoning Framework}
\label{sec:reasoning}

We now describe a proof system that lets us prove the correctness of a \txnimp
program $c$ w.r.t its high-level invariant $I$, on a machine that
satisfies the isolation specifications ($\I$) of its
transactions\footnote{Note the difference between $I$ and $\I$. The
former constitute \emph{proof} \emph{obligations} for the programmer,
whereas the latter describes a transaction's \emph{assumptions} about
operational characteristics of the underlying machine.}.  Our proof
system is essentially an adapatation of the rely-guarantee reasoning
framework to the setting of weakly isolated database transactions. It
deals with the additional complexity introduced by this setting, while
also taking advantage of the opportunities it provides to simplify the
reasoning. The primary challenge is the weak isolation; how do we
relate a transaction's isolation specification ($\I$) to its rely
relation ($R$) that describes the environment, so that the
interference is considered only insofar as the isolation level allows
it? Our proof system shows how to compute a rely relation ($R$) modulo
the isolation specification ($\I$) of a transaction. Another
characteristic of the transaction setting is the atomicity of a
trasaction's aggregate writes; a transaction's writes are not visible
to its peers until it commits. In the context of rely-guarantee, this
means that the transactions guarantee ($G$) should capture the
aggregate effect of a transaction, and not its individual writes.
While \C{atomic} blocks are also present in the shared-memory
programs, the fact that a transactions are weakly isolated introduces
complexity.  Unlike an \C{atomic} block, the effect of a transaction
is \emph{not} a sequential composition of the effects of its
statements because each statement witnesses a potentially different
version of the state. This is illustrated in
Fig.~\ref{fig:atomic-vs-transaction}, where a series of operations on
\C{x} can be composed to describe the effect of an \C{atomic} block,
while same cannot be done in a transaction. Thus, weak isolation needs
to be taken into account when defining and verifying guarantees, and
our proof system shows how. 

\subsection{The Rely-Guarantee Judgment}
\label{sec:rely-guarantee}

\input{rg-rules}

Fig.~\ref{fig:rg-rules} shows an illustrative subset of the
rely-guarantee (RG) reasoning rules for $\txnimp$. We define two RG
judgments: top-level ($\rg{I,R}c{G,I}$), and transaction-local ($\R
\vdash \hoare{P}c{Q}$).  Recall that the standard RG judgment is the
quintuple $\rg{P,R}{c}{G,Q}$. Instead of a separate $P$ and $Q$, our
top-level judgment has $I$ for both pre- and post-conditions, because
our focus is on verifying that a \txnimp program \emph{preserves}
database's consistency conditions\footnote{The terms \emph{consistency
condition}, \emph{high-level invaraint}, and \emph{integrity
constraint} all mean the same.}. Transaction-local RG judgment doesn't
include a guarantee relation because transaction-local effects are not
visible outside a transaction. Also, the rely relation ($\R$) of the
transaction-local judgment is not same as the top-level rely relation
($R$) as it takes into account the transaction's isolation
specification ($\I$). Intuitively, $\R$ is $R$ modulo $\I$; formal
definition will be given shortly. Recall that a transaction writes to
its local database ($\stl$), which is then flushed when the
transaction commits. Thus, the guarantee of a transaction depends on
the state of its local database at the commit point. The pre- and
post-condition assertions ($P$ and $Q$) in the local judgment
facilitate tracking the changes to the transaction-local state, which
eventually helps us prove the validity of the transaction's guarantee.
Note that $P$ and $Q$ are bi-state assertions; they relate
transaction-local database state ($\stl$) to the global database state
($\stg$). Thus, the transaction-local judgment effectively tracks how
transaction-local and global states change in relation to each other.

The quintessential aspect of a rely-guarantee judgment is the
stability condition, which, intuitively, requires the validity of an
assertion $\phi$ to be unaffacted by the interference, i.e., the rely
relation $R$. In conventional RG, stability is defined as following
($\sigma$ denotes a state):
\begin{smathpar}
\begin{array}{lcl}
\stable(R,\phi) & \Leftrightarrow & \forall \sigma,\sigma'.~
\phi(\sigma) \conj R(\sigma,\sigma') \Rightarrow \phi(\sigma')\\
\end{array}
\end{smathpar}
Due to the presence of local and global database states, and isolation
specification, we use multiple definitions of stability in
Fig.~\ref{fig:rg-rules}, but they all convey the same intuition as
above. We will introduce them as they are encountered.

\rulelabel{RG-Txn} is the top-level rule that lets us prove a
transaction preserves the high-level invariant $I$ when executed under
the required isolation as specified by $\I$. It relies on the
transaction-local judgment to verify the the transaction body ($c$).
The precondition $P$ of $c$ must follow from the fact that the
transaction-local database ($\stl$) is initially empty, and the global
database satisfies the high-level invariant $I$. The rely relation
($\R_l$) for the local judgment is a ternary relation computed as $R$
modulo $\I$ as following:
\begin{smathpar}
\begin{array}{lcl}
\R_l(\stl,\stg,\stg') & \Leftrightarrow & R(\stg,\stg') \conj
\I\,\C{true}\,(\stl,\stg,\stg')
\end{array}
\end{smathpar}
Thus, $\R_l$ allows an interference only if it doesn't violate the
execution-time isolation specification of the transaction. If a
certain interference violates the isolation spec, i.e., $R(\stg,\stg')
\Rightarrow \neg(\I\,\C{true}\,(\stl,\stg,\stg'))$, then
$\R_l(\stl,\stg,\stg') \Leftrightarrow false$, and any assertion is
trivially stable w.r.t that interference. This is sensible considering
such interference is pre-empted in the operational semantics. 

Recall that $P$ and $Q$ of the transaction-local RG judgment are
binary assertions; they relate local and global database states. The
local judgment rules require one or both of them to be stable. The
stability of a binary assertion $Q$ w.r.t a ternary rely relation $\R$
is defined as following:
\begin{smathpar}
\begin{array}{c}
\forall \stl,\stg,\stg'.~ Q(\stl,\stg) \conj \R(\stl,\stg,\stg')
\Rightarrow Q(\stl,\stg')
\end{array}
\end{smathpar}
That is, if $Q$ relates $\stl$ to $\stg$, and an interference allowed
by the isolation specfication (which implicitly considers the local
state $\stl$) takes $\stg$ to $\stg'$, the $Q$ must also relate $\stl$
to $\stg'$.

For the guarantee $G$ of the transaction to be valid, it must follow
from the post-condition $Q$ of the body, provided that $Q$ is stable
w.r.t the commit-time interference captured by $R_c$. $R_c$, like
$R_l$, is computed as rely relation modulo isolation, except that
commit-time isolation ($\I\,\C{false}$) is considered. The validity of
$G$ is captured by the following implication:
\begin{smathpar}
\begin{array}{c}
  \forall \stl,\stg.~ Q(\stl,\stg) \Rightarrow G(\stg, \stl \gg \stg)\spc
\end{array}
\end{smathpar}
In other words, if $Q$ relates the transaction-local database state
($\stl$) to the state of the global database ($\stg$) before the
commit, then $G$ must relate the states of the global database before
and after the commit. The act of commit captured by the flush
operation ($\stl\gg\stg$). Once we establish the validity of $G$ as a
faithful representative of the transaction, we can verify that the
transaction preserves the high-level invariant $I$ by checking the
stability of $I$ w.r.t $G$, i.e., $\forall \stg,\stg'.~I(\stg) \wedge
G(\stg,\stg') \Rightarrow I(\stg')$.

A characteristic of RG reasoning is that stability of an assertion is
always proven w.r.t to $R$, and not $R^{*}$, although interference may
include multiple environment steps, and $R$ only captures a single
step. This is nonetheless sound due to the the inductive reasoning: if
$Q$ is preserved by every step of $R$, then $Q$ is preserved by
$R^{*}$, and vice-versa.  However, such reasoning does not extend
naturally to isolation-constrained interference because $R^{*}$ modulo
$\I$ is not same as $\R^{*}$; the former is a transitive relation
constrained by $\I$, whereas the latter is the transitive closure of a
$\I$-constrained relation. We therefore introduce a side-condition on
$\I$ that restores the equality. The condition requires $\I$ to allow
an intereference $R^{*}(\stg,\stg'')$, for two database states $\stg$
and $\stg''$, only if it also allows interference for every prefix of
$R^{*}(\stg,\stg'')$. In other words, if $\I$ disallows interference
from $\stg$ to $\stg'$, then an $R$-step from $\stg'$ to $\stg''$
shouldn't make the interference from $\stg$ to $\stg''$ valid. We call
this the stability condition on $\I$, defined as below:
\begin{smathpar}
\begin{array}{lcl}
  \stable(R,\I) & \Leftrightarrow & \forall \stl,\stg,\stg',\stg''.~
  \neg\I(\stl,\stg,\stg') \conj R(\stg',\stg'') \Rightarrow
  \neg\I(\stl,\stg,\stg'')
\end{array}
\end{smathpar}
It can be easily verified that the above stability condition is
satisfied by the isolation axioms from Sec.~\ref{sec:isolation}. For
instance, $\I_{ss}$, the snapshot axiom, is stable because if
$\I_{ss}$ is invalid, then an interference has already modified a
record, and no further interference will restore the original record,
because original record bears the id of a transaction that has long
committed. Thus, $\I_{ss}$ remains invalid.

The \rulelabel{RG-Conseq} rule lets us safely strengthen the guarantee
$G$, or weaken the rely $R$ of a transaction. Importantly, it also
allows its isolation specification $\I$ to be strengthened. This means
that a transaction proven correct under a weaker isolation level is
also correct under a stronger level. Parametricity over the isolation
specification $\I$, combined with the ability to strengthen $\I$ as
needed, admits a flexible proof strategy to prove database programs
correct. For example, programmers can declare isolation requirements
of their choice through $\I$, and then prove programs correct assuming
the guarantees hold. The soundness of strengthening $\I$ ensures that
a program can be safely executed on any system that offers isolation
guarantees at least as strong as those assumed.

Two rules of the transaction-local RG judgment are shown in
Fig.~\ref{fig:rg-rules}. The rule \rulelabel{RG-Update} is
illustrative of the RG rules for SQL statements; they basically
reflect the structure of the corresponding reduction rule from
Fig.~\ref{fig:txnimp}, and require no further explanation. The rule
\rulelabel{RG-Foreach} defines the RG judgment for a \C{FOREACH} loop.
As is characteristic of loops, the reasoning is pivoted on a loop
invariant $\I$ (not same as the high-level invariant), that needs to
be stable w.r.t $\R$. $I$ must follow $P$, the pre-condition of
\C{FOREACH}, when no elements have been iterated, i.e, when
$y=\emptyset$. The body of the loop can assume the loop invariant, and
the fact that $z$ is an element from the set $x$ being iterated, to
prove its post-condition $Q_c$. Operational semantics ensures that $z$
is added to $y$ at the end of the iteration, hence $Q_c \conj z\in y$
is valid at the end of the iteration, from which $I$ must follow. When
\C{FOREACH} has finished execution, $y$, the set of iterated items, is
the entire set $x$. Thus $I \conj y=x$ must imply the post-condition
$Q$, which also needs to be stable. The rules for conditionals,
sequencing etc., are more-or-less standard, hence elided.

\subsection{Semantics and Soundness}

\begin{definition}[\bfseries Step-indexed reflexive transitive closure]
For all $A:\text{Type}$, $R: A \rightarrow A \rightarrow \mathbb{P}$, and $n :
\mathbb{N}$, the step-indexed reflexive transitive closure $R^n$ of $R$ is
the smallest relation satisfying the following
properties:
\begin{itemize}
\item $\forall (x:A).\, R^0 (x,x)$
\item $\forall (n:\mathbb{N})(x,y,z : A).\, R(x,y) \conj R^n(y,z) \Rightarrow
R^{n+1}(x,z)$
\end{itemize}
\end{definition}

% \begin{definition}[\bfseries Interleaved step and multi-step relations]
% An interleaved step relation interleaves transaction-local reductions with
% legal interference from concurrent transactions as defined by the
% $\I$-constrained rely relation ($\R$).  It is defined thus:
% \begin{smathpar}
% \begin{array}{lcl}
% (c,\stl,\stg) \rstepsto (c',\stl',\stg') & \defeq & \stg \vdash 
%   (c,\stl) \stepsto (c',\stl') \conj \stg'=\stg \\
%   &   & \disj (c' = c \conj \stl'=\stl \conj \R(\stl, \stg, \stg'))\\
% \end{array}
% \end{smathpar}

\begin{definition}[\bfseries Interleaved step and multi-step relations]
An interleaved step relation interleaves a transaction's reduction with
interference from concurrent transactions as captured by the rely
relation. It is defined thus:
\begin{smathpar}
\begin{array}{lcl}
(c,\stg) \rstepsto (c',\stg') & \defeq &  
  (c,\stg) \stepsto (c',\stg') \disj (c' = c \conj R(\stg, \stg'))\\
\end{array}
\end{smathpar}

\noindent The interleaved step relation for transaction bound expressions
($\txnbox{e}_i$) and commands ($\txnbox{c}_i$) is defined similarly.
An interleaved multi-step relation ($\stepssto{n}$) is the step-indexed
reflexive transitive closure of the interleaved step relation.
\end{definition}

\begin{definition}[\bfseries Semantics of the RG judgment]
\label{def:rg-semantics}
The semantics of the RG sextuple $\rg{\mathbb{I},P,R}{c}{G,Q}$ is defined
in terms of the interleaved step relation thus:\vspace*{-10pt}

\begin{smathpar}
\begin{array}{l}
\hspace*{-0.3in}
\rg{\mathbb{I},P,R}{c}{G,Q} \;\defeq\; \forall \E.\, P(\E)
  \wedge \mathbb{I}(\E) \\
\hspace*{0.4in}\Rightarrow (\forall n,\E'.\; \I \vdash (c,\E) 
    \rstepssto{n} (\cskip,\E') \Rightarrow Q(\E')) \\
\hspace*{0.5in}\conj \texttt{step-guaranteed}(\I,R,G,c,\E)\\
\end{array}
\end{smathpar}

\noindent The first conjunct in the consequent is called the \emph{Hoare
consequent} since it ascribes Hoare triple semantics to an RG sextuple.
The second conjunct, called the \emph{guarantee consequent}, uses the
$\texttt{step-guaranteed}$ predicate defined below:\vspace*{-10pt}

\begin{smathpar}
\begin{array}{l}
\texttt{step-guaranteed}(\I,R,G,c,\E) \;\defeq\; \forall n,\E',c'',\E''.\\
\hspace*{0.2in}\I \vdash (c,\E) \rstepssto{n} (c',\E') \conj \I \vdash (c',\E') \stepsto
  (c'',\E'') \Rightarrow G(\E',\E'')\\
\end{array}
\end{smathpar}

\noindent The guarantee consequent requires $G$ to capture the trace effect of
every small-step of $c$, where the reduction can be interleaved by the
interference ($R$) from concurrent threads. The semantics of the RG
sextuple for transaction-bound commands ($\txnbox{c}_i$) is defined
similarly. Expressions, unlike commands, evaluate to a value $v$, and
the semantics of their RG septuple ($\rg{\I,P,R}{\txnbox{e}_i}{G,C,Q}$) differs slightly in that its
Hoare consequent requires the value $v$ to satisfy the assertion $C$. 
\end{definition}

Note that the semantics of all RG judgments, including the judgments
for transaction-bound terms, make similar demands of the guarantee
relation. Given that transactions are atomic (though not isolated), it
is not immediately apparent why a transaction's guarantee is required
to make explicit every step of its reduction. This requirement is
justified however because, in reality, a transaction's atomicity is
predicated on the isolation settings of the observer. A \iso{Read
  Uncommitted} transaction, for example, is permitted to observe the
internal state of a transaction $T$ even if $T$ is claimed to execute
atomically.  In the interest of modular verification, the transaction
must therefore make its internal state available via its guarantee
relation.

\begin{theorem}[\bfseries Soundness] 
The rely-guarantee judgments defined by the rules in
Fig.~\ref{fig:rg-rules} are sound with respect to the semantics of
Definition~\ref{def:rg-semantics}.\footnote{Formal proof of soundness
is provided in the supplementary material.}
\end{theorem}

\noindent In particular, if $\rg{\I,P,R}{c}{G,Q}$ can be derived using
the rules of Fig.~\ref{fig:rg-rules}, then (a) every interleaved
multi-step reduction of $c$ starting from a trace that satisfies $P$
and $\I$, results in a trace that satisfies $Q$, and (b) the effect
that every small-step of $c$ has on the trace is contained in $G$.
Soundness of the RG judgment for transaction-bound commands
($\txnbox{c}_i$) is stated similarly.  For expressions, soundness of
the judgment $\rg{\I,P,R}{\txnbox{e}_i}{G,C,Q}$ also proves that $e$
is always evaluated to a value that satisfies $C$.

