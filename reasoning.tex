\section{The Reasoning Framework}
\label{sec:reasoning}

We now describe a proof system that lets us prove the correctness of a \txnimp
program $c$ w.r.t its high-level invariant $I$, on a machine that
satisfies the isolation specifications ($\I$) of its
transactions\footnote{Note the difference between $I$ and $\I$. The
former constitute \emph{proof} \emph{obligations} for the programmer,
whereas the latter describes a transaction's \emph{assumptions} about
operational characteristics of the underlying machine.}.  Our proof
system is essentially an adapatation of the rely-guarantee reasoning
framework to the setting of weakly isolated database transactions. It
deals with the additional complexity introduced by this setting, while
also taking advantage of the opportunities it provides to simplify the
reasoning. The primary challenge is the weak isolation; how do we
relate a transaction's isolation specification ($\I$) to its rely
relation ($R$) that describes the environment, so that the
interference is considered only insofar as the isolation level allows
it? Our proof system shows how to compute a rely relation ($R$) modulo
the isolation specification ($\I$) of a transaction. Another
characteristic of the transaction setting is the atomicity of a
trasaction's aggregate writes; a transaction's writes are not visible
to its peers until it commits. In the context of rely-guarantee, this
means that the transactions guarantee ($G$) should capture the
aggregate effect of a transaction, and not its individual writes.
While \C{atomic} blocks are also present in the shared-memory
programs, the fact that a transactions are weakly isolated introduces
complexity.  Unlike an \C{atomic} block, the effect of a transaction
is \emph{not} a sequential composition of the effects of its
statements because each statement witnesses a potentially different
version of the state. This is illustrated in
Fig.~\ref{fig:atomic-vs-transaction}, where a series of operations on
\C{x} can be composed to describe the effect of an \C{atomic} block,
while same cannot be done in a transaction. Thus, weak isolation needs
to be taken into account when defining and verifying guarantees, and
our proof system shows how. 

\subsection{The Rely-Guarantee Judgment}
\label{sec:rely-guarantee}

\input{rg-rules}

Fig.~\ref{fig:rg-rules} shows an illustrative subset of the
rely-guarantee (RG) reasoning rules for $\txnimp$. We define two RG
judgments: top-level ($\rg{I,R}c{G,I}$), and transaction-local ($\R
\vdash \hoare{P}c{Q}$).  Recall that the standard RG judgment is the
quintuple $\rg{P,R}{c}{G,Q}$. Instead of a separate $P$ and $Q$, our
top-level judgment has $I$ for both pre- and post-conditions, because
our focus is on verifying that a \txnimp program \emph{preserves}
database's consistency conditions\footnote{The terms \emph{consistency
condition}, \emph{high-level invaraint}, and \emph{integrity
constraint} all mean the same.}. Transaction-local RG judgment doesn't
include a guarantee relation because transaction-local effects are not
visible outside a transaction. Also, the rely relation ($\R$) of the
transaction-local judgment is not same as the top-level rely relation
($R$) as it takes into account the transaction's isolation
specification ($\I$). Intuitively, $\R$ is $R$ modulo $\I$; formal
definition will be given shortly. Recall that a transaction writes to
its local database ($\stl$), which is then flushed when the
transaction commits. Thus, the guarantee of a transaction depends on
the state of its local database at the commit point. The pre- and
post-condition assertions ($P$ and $Q$) in the local judgment
facilitate tracking the changes to the transaction-local state, which
eventually helps us prove the validity of the transaction's guarantee.
Note that $P$ and $Q$ are bi-state assertions; they relate
transaction-local database state ($\stl$) to the global database state
($\stg$). Thus, the transaction-local judgment effectively tracks how
transaction-local and global states change in relation to each other.

The quintessential aspect of a rely-guarantee judgment is the
stability condition, which, intuitively, requires the validity of an
assertion $\phi$ to be unaffacted by the interference, i.e., the rely
relation $R$. In conventional RG, stability is defined as following
($\sigma$ denotes a state):
\begin{smathpar}
\begin{array}{lcl}
\stable(R,\phi) & \Leftrightarrow & \forall \sigma,\sigma'.~
\phi(\sigma) \conj R(\sigma,\sigma') \Rightarrow \phi(\sigma')\\
\end{array}
\end{smathpar}
Due to the presence of local and global database states, and isolation
specification, we use multiple definitions of stability in
Fig.~\ref{fig:rg-rules}, but they all convey the same intuition as
above. We will introduce them as they are encountered.

\rulelabel{RG-Txn} is the top-level rule that lets us prove a
transaction preserves the high-level invariant $I$ when executed under
the required isolation as specified by $\I$. It relies on the
transaction-local judgment to verify the the transaction body ($c$).
The precondition $P$ of $c$ must follow from the fact that the
transaction-local database ($\stl$) is initially empty, and the global
database satisfies the high-level invariant $I$. The rely relation
($\R_l$) for the local judgment is a ternary relation computed as $R$
modulo $\I$ as following:
\begin{smathpar}
\begin{array}{lcl}
\R_l(\stl,\stg,\stg') & \Leftrightarrow & R(\stg,\stg') \conj
\I\,\C{true}\,(\stl,\stg,\stg')
\end{array}
\end{smathpar}
Thus, $\R_l$ allows an interference only if it doesn't violate the
execution-time isolation specification of the transaction. If a
certain interference violates the isolation spec, i.e., $R(\stg,\stg')
\Rightarrow \neg(\I\,\C{true}\,(\stl,\stg,\stg'))$, then
$\R_l(\stl,\stg,\stg') \Leftrightarrow false$, and any assertion is
trivially stable w.r.t that interference. This is sensible considering
such interference is pre-empted in the operational semantics. 

Recall that $P$ and $Q$ of the transaction-local RG judgment are
binary assertions; they relate local and global database states. The
local judgment rules require one or both of them to be stable. The
stability of a binary assertion $Q$ w.r.t a ternary rely relation $\R$
is defined as following:
\begin{smathpar}
\begin{array}{c}
\forall \stl,\stg,\stg'.~ Q(\stl,\stg) \conj \R(\stl,\stg,\stg')
\Rightarrow Q(\stl,\stg')
\end{array}
\end{smathpar}
That is, if $Q$ relates $\stl$ to $\stg$, and an interference allowed
by the isolation specfication (which implicitly considers the local
state $\stl$) takes $\stg$ to $\stg'$, the $Q$ must also relate $\stl$
to $\stg'$.

For the guarantee $G$ of the transaction to be valid, it must follow
from the post-condition $Q$ of the body, provided that $Q$ is stable
w.r.t the commit-time interference captured by $R_c$. $R_c$, like
$R_l$, is computed as rely relation modulo isolation, except that
commit-time isolation ($\I\,\C{false}$) is considered. The validity of
$G$ is captured by the following implication:
\begin{smathpar}
\begin{array}{c}
  \forall \stl,\stg.~ Q(\stl,\stg) \Rightarrow G(\stg, \stl \gg \stg)\spc
\end{array}
\end{smathpar}
In other words, if $Q$ relates the transaction-local database state
($\stl$) to the state of the global database ($\stg$) before the
commit, then $G$ must relate the states of the global database before
and after the commit. The act of commit captured by the flush
operation ($\stl\gg\stg$). Once we establish the validity of $G$ as a
faithful representative of the transaction, we can verify that the
transaction preserves the high-level invariant $I$ by checking the
stability of $I$ w.r.t $G$, i.e., $\forall \stg,\stg'.~I(\stg) \wedge
G(\stg,\stg') \Rightarrow I(\stg')$.

A characteristic of RG reasoning is that stability of an assertion is
always proven w.r.t to $R$, and not $R^{*}$, although interference may
include multiple environment steps, and $R$ only captures a single
step. This is nonetheless sound due to the the inductive reasoning: if
$Q$ is preserved by every step of $R$, then $Q$ is preserved by
$R^{*}$, and vice-versa.  However, such reasoning does not extend
naturally to isolation-constrained interference because $R^{*}$ modulo
$\I$ is not same as $\R^{*}$; the former is a transitive relation
constrained by $\I$, whereas the latter is the transitive closure of a
$\I$-constrained relation. We therefore introduce a side-condition on
$\I$ that restores the equality. The condition requires $\I$ to allow
an intereference $R^{*}(\stg,\stg'')$, for two database states $\stg$
and $\stg''$, only if it also allows interference for every prefix of
$R^{*}(\stg,\stg'')$. In other words, if $\I$ disallows interference
from $\stg$ to $\stg'$, then an $R$-step from $\stg'$ to $\stg''$
shouldn't make the interference from $\stg$ to $\stg''$ valid. We call
this the stability condition on $\I$, defined as below:
\begin{smathpar}
\begin{array}{lcl}
  \stable(R,\I) & \Leftrightarrow & \forall \stl,\stg,\stg',\stg''.~
  \neg\I(\stl,\stg,\stg') \conj R(\stg',\stg'') \Rightarrow
  \neg\I(\stl,\stg,\stg'')
\end{array}
\end{smathpar}
It can be easily verified that the above stability condition is
satisfied by the isolation axioms from Sec.~\ref{sec:isolation}. For
instance, $\I_{ss}$, the snapshot axiom, is stable because if
$\I_{ss}$ is invalid, then an interference has already modified a
record, and no further interference will restore the original record,
because original record bears the id of a transaction that has long
committed. Thus, $\I_{ss}$ remains invalid.

The \rulelabel{RG-Conseq} rule lets us safely strengthen the guarantee
$G$, or weaken the rely $R$ of a transaction. Importantly, it also
allows its isolation specification $\I$ to be strengthened. This means
that a transaction proven correct under a weaker isolation level is
also correct under a stronger level. Parametricity over the isolation
specification $\I$, combined with the ability to strengthen $\I$ as
needed, admits a flexible proof strategy to prove database programs
correct. For example, programmers can declare isolation requirements
of their choice through $\I$, and then prove programs correct assuming
the guarantees hold. The soundness of strengthening $\I$ ensures that
a program can be safely executed on any system that offers isolation
guarantees at least as strong as those assumed.

Two rules of the transaction-local RG judgment are shown in
Fig.~\ref{fig:rg-rules}. The rule \rulelabel{RG-Update} is
illustrative of the RG rules for SQL statements; they basically
reflect the structure of the corresponding reduction rule from
Fig.~\ref{fig:txnimp}, and require no further explanation. The rule
\rulelabel{RG-Foreach} defines the RG judgment for a \C{FOREACH} loop.
As is characteristic of loops, the reasoning is pivoted on a loop
invariant $\I$ (not same as the high-level invariant), that needs to
be stable w.r.t $\R$. $I$ must follow $P$, the pre-condition of
\C{FOREACH}, when no elements have been iterated, i.e, when
$y=\emptyset$. The body of the loop can assume the loop invariant, and
the fact that $z$ is an element from the set $x$ being iterated, to
prove its post-condition $Q_c$. Operational semantics ensures that $z$
is added to $y$ at the end of the iteration, hence $Q_c \conj z\in y$
is valid at the end of the iteration, from which $I$ must follow. When
\C{FOREACH} has finished execution, $y$, the set of iterated items, is
the entire set $x$. Thus $I \conj y=x$ must imply the post-condition
$Q$, which also needs to be stable. The rules for conditions,
sequencing etc., are more-or-less standard, hence elided.

% \subsection{Semantics and Soundness}

% The rules that define rely-guarantee judgment are shown in
% Fig.~\ref{fig:rg-rules}. Like standard rely-guarantee definitions,
% these definitions also require a \emph{stability} condition, which
% requires pre- and post- conditions to hold despite any interference
% from concurrent threads (captured by $R$). Stability can be predicated
% on the assumption that interference preserves the trace invariant
% $\I$. Formally:\vspace*{-10pt}

% \begin{smathpar}
% \begin{array}{lcl}
%   \underI{\stable(R,P)} & \defeq & \forall \E, \E'.\, 
%   \I(\E) \conj P(\E) \conj R(\E,\E') \\
%   &   & \hspace*{1in}\conj \I(\E') \Rightarrow P(\E')\\
% \end{array}
% \end{smathpar}

% \noindent However, the assumption that interference preserves $\I$ (or,
% dually, $\I$ withstands interference) needs to be justified
% separately. We call this the stability requirement on $\I$:\vspace*{-10pt}

% \begin{smathpar}
% \begin{array}{lcl}
% \stable(R,\I)& \defeq & \forall \E, \E'.\, 
%   \I(\E) \conj R(\E,\E')\Rightarrow \I(\E')\\
% \end{array}
% \end{smathpar}

% \noindent The rule \rulelabel{RG-Var} defines the rely-guarantee judgment for
% shared variable reads inside a transaction $T_i$. It requires $\I$ to
% be stable, and pre- and post- conditions to be stable relative to
% $\I$.  The quantified premise effectively requires a proof that if the
% abstract machine of Fig.~\ref{fig:txnimp} takes a step starting from
% an execution $\E$ that satisfies the pre-condition $P$, then the
% resultant execution $\E'$ satisfies the post-condition $Q$, and that
% the guarantee $G$ faithfully captures the transition from $\E$ to
% $\E'$. It is informative to compare this premise with the premise of
% the \rulelabel{E-Aux} reduction rule of Fig.~\ref{fig:txnimp}. Similar
% premises also appear in the \rulelabel{RG-Asgn} and \rulelabel{RG-Txn}
% rules, which define rely-guarantee judgments for assignments and
% transactions, respectively. \rulelabel{RG-Var} however also requires
% the return value ($\interp{S}(X)$) of the read to satisfy the
% assertion $C$ meant for the value. \rulelabel{RG-Arith} defines the RG
% judgment for an arithmetic expression $e_1\pm e_2$ in terms of the
% corresponding judgments for the constituent expressions $e_1$ and
% $e_2$. The quantified premise requires any value resulting from
% evaluating $e_1 \pm e_2$ to satisfy the assertion $C$, provided that
% $e_1$ and $e_2$ always evaluate to values that satisfy $C_1$ and
% $C_2$, respectively. The rules for sequential and parallel composition
% of commands are essentially the same as their counterparts in a
% standard rely-guarantee formulation and hence elided.

% % RG judgment for the assignment $X:=e$ makes use of the corresponding
% % judgment for the RHS expression $e$. The quantified premise asserts
% % that evaluating the assigment after evaluating $e$ to a value $v$ and
% % an execution $\E$, should result in an execution $\E'$ that satisfies
% % the post-condition $Q$, while being related to $\E$ via the guarantee
% % $G$. RG judgment for the \C{txn} lexical block is similar.  It uses
% % the judgment for the transaction-bound command $c$ (i.e.,
% % $\txnbox{c}_i$) to obtain an invariant $Q'$ for the execution $\E$
% % before the commit, and verifies that committing the transaction under
% % $\E$ results in an execution $\E'$ that satisfies transaction's
% % post-condition $Q$. As usual, $\E$ and $\E'$ need to be related by $G$.
% % The rules for sequential composition of transaction-bound comands
% % (\rulelabel{RG-Seq}) and parallel composition of top-level commands
% % (\rulelabel{RG-Par}) are straightforward, and more-or-less same as the
% % corresponding rules in classical rely-guarantee.

% The \rulelabel{RG-Conseq} rule defines ways to strengthen or
% weaken relations and assertions associated with the RG judgment of
% transaction-bound expressions. Similar rules exist for
% transaction-bound and top-level commands, but are not
% shown.\footnote{The supplementary materials provide the complete set
%   of rules.} As is the case with a standard rely-guarantee
% formulation,the rules allow the pre-condition $P$ and the rely relation
% $R$ to be strengthened, and the post-condition $Q$ (also, $C$ in the
% case of expressions) and the guarantee relation $G$ to be weakened.
% The most notable aspect of the \rulelabel{RG-Conseq} rules is that
% they allow the trace invariant $\I$ to be strengthened. Considering
% that $\I$ captures isolation properties, this means that a program
% proven correct under weaker isolation levels is also correct under
% stronger ones.  Parametricity over the trace invariant $\I$, combined
% with the ability to strengthen $\I$ as needed, allows our proof system
% to support a highly flexible proof strategy to prove programs correct
% over various isolation variants. For example, programmers can
% \emph{define} isolation guarantees of their choice (by defining $\I$
% appropriately) and then prove programs correct assuming the guarantees
% hold.  The soundness of strengthening $\I$ ensures that a program can
% be safely executed on any system that offers isolation guarantees
% at least as strong as those assumed.

\subsection{Semantics and Soundness}

\begin{definition}[\bfseries Step-indexed reflexive transitive closure]
For all $A:\text{Type}$, $R: A \rightarrow A \rightarrow \mathbb{P}$, and $n :
\mathbb{N}$, the step-indexed reflexive transitive closure $R^n$ of $R$ is
the smallest relation satisfying the following
properties:
\begin{itemize}
\item $\forall (x:A).\, R^0 (x,x)$
\item $\forall (n:\mathbb{N})(x,y,z : A).\, R(x,y) \conj R^n(y,z) \Rightarrow
R^{n+1}(x,z)$
\end{itemize}
\end{definition}

\begin{definition}[\bfseries Interleaved step and multi-step relations]
An interleaved step relation interleaves thread-local reductions with
interference from concurrent threads captured as the rely relation
($R$).  It is defined thus:\vspace*{-10pt}

\begin{smathpar}
\begin{array}{lcl}
\I \vdash (c,\E) \rstepsto (c',\E') & \defeq & \I \vdash 
  (c,\E) \stepsto (c',\E') \\
  &   & \disj (c' = c \conj R(\E, \E') \conj \I(\E'))\\
\end{array}
\end{smathpar}

\noindent The interleaved step relation for transaction bound expressions
($\txnbox{e}_i$) and commands ($\txnbox{c}_i$) is defined similarly.
An interleaved multi-step relation ($\stepssto{n}$) is the step-indexed
reflexive transitive closure of the interleaved step relation.
\end{definition}

\begin{definition}[\bfseries Semantics of the RG judgment]
\label{def:rg-semantics}
The semantics of the RG sextuple $\rg{\mathbb{I},P,R}{c}{G,Q}$ is defined
in terms of the interleaved step relation thus:\vspace*{-10pt}

\begin{smathpar}
\begin{array}{l}
\hspace*{-0.3in}
\rg{\mathbb{I},P,R}{c}{G,Q} \;\defeq\; \forall \E.\, P(\E)
  \wedge \mathbb{I}(\E) \\
\hspace*{0.4in}\Rightarrow (\forall n,\E'.\; \I \vdash (c,\E) 
    \rstepssto{n} (\cskip,\E') \Rightarrow Q(\E')) \\
\hspace*{0.5in}\conj \texttt{step-guaranteed}(\I,R,G,c,\E)\\
\end{array}
\end{smathpar}

\noindent The first conjunct in the consequent is called the \emph{Hoare
consequent} since it ascribes Hoare triple semantics to an RG sextuple.
The second conjunct, called the \emph{guarantee consequent}, uses the
$\texttt{step-guaranteed}$ predicate defined below:\vspace*{-10pt}

\begin{smathpar}
\begin{array}{l}
\texttt{step-guaranteed}(\I,R,G,c,\E) \;\defeq\; \forall n,\E',c'',\E''.\\
\hspace*{0.2in}\I \vdash (c,\E) \rstepssto{n} (c',\E') \conj \I \vdash (c',\E') \stepsto
  (c'',\E'') \Rightarrow G(\E',\E'')\\
\end{array}
\end{smathpar}

\noindent The guarantee consequent requires $G$ to capture the trace effect of
every small-step of $c$, where the reduction can be interleaved by the
interference ($R$) from concurrent threads. The semantics of the RG
sextuple for transaction-bound commands ($\txnbox{c}_i$) is defined
similarly. Expressions, unlike commands, evaluate to a value $v$, and
the semantics of their RG septuple ($\rg{\I,P,R}{\txnbox{e}_i}{G,C,Q}$) differs slightly in that its
Hoare consequent requires the value $v$ to satisfy the assertion $C$. 
\end{definition}

Note that the semantics of all RG judgments, including the judgments
for transaction-bound terms, make similar demands of the guarantee
relation. Given that transactions are atomic (though not isolated), it
is not immediately apparent why a transaction's guarantee is required
to make explicit every step of its reduction. This requirement is
justified however because, in reality, a transaction's atomicity is
predicated on the isolation settings of the observer. A \iso{Read
  Uncommitted} transaction, for example, is permitted to observe the
internal state of a transaction $T$ even if $T$ is claimed to execute
atomically.  In the interest of modular verification, the transaction
must therefore make its internal state available via its guarantee
relation.

\begin{theorem}[\bfseries Soundness] 
The rely-guarantee judgments defined by the rules in
Fig.~\ref{fig:rg-rules} are sound with respect to the semantics of
Definition~\ref{def:rg-semantics}.\footnote{Formal proof of soundness
is provided in the supplementary material.}
\end{theorem}

\noindent In particular, if $\rg{\I,P,R}{c}{G,Q}$ can be derived using
the rules of Fig.~\ref{fig:rg-rules}, then (a) every interleaved
multi-step reduction of $c$ starting from a trace that satisfies $P$
and $\I$, results in a trace that satisfies $Q$, and (b) the effect
that every small-step of $c$ has on the trace is contained in $G$.
Soundness of the RG judgment for transaction-bound commands
($\txnbox{c}_i$) is stated similarly.  For expressions, soundness of
the judgment $\rg{\I,P,R}{\txnbox{e}_i}{G,C,Q}$ also proves that $e$
is always evaluated to a value that satisfies $C$.

